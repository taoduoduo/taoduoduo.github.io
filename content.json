{"meta":{"title":"从设计到实现","subtitle":"手把手教你做android应用开发","description":"手把手教你做android应用开发","author":"安豆","url":"http://booktest.anddle.com"},"pages":[{"title":"","date":"2017-02-16T15:27:16.000Z","updated":"2017-02-16T15:27:16.000Z","comments":true,"path":"404.html","permalink":"http://booktest.anddle.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2017-01-30T01:00:00.000Z","updated":"2017-02-17T03:11:28.000Z","comments":false,"path":"about/index.html","permalink":"http://booktest.anddle.com/about/index.html","excerpt":"","text":"@card{ 谁应该读这本书当我们面对生活中各种让你感动的创意、作品之时，一定有过这样的想法：假如这是我自己设计并做出来的，那该多好啊。 是啊，假如有一件完全由自己产生的作品，能够带给别人方便与快乐，能够受到别人的欣赏，那该是一件多么幸福的事情。 作为设计师的我们，作为程序员的我们，也许相比其他人，能够更加方便、容易的实现自己这个小小的心愿。因为把一个自己理想的App创意，变成一个实实在在的产品，并不会花费太多的经济成本，几乎就是一个大脑，一台电脑，一点时间就能完成的事情。 对于设计师而言，设计不是问题，“只差一个程序员就能搞定了”。 对于程序员而言，实现不是问题，“只差一个好的设计就能搞定了”。 不过实际生活中，那些伟大的创意有可能被“只差一个”的想法给拦住，始终没有破土而出的那一天：“另一半”，总是很难找的。 即使幸运的觅得了“另一半”，也可能因为对对方“理解”的不深刻而分道扬镳，“我的设计那么好，他怎么就不能实现呢？” “我的技术那么好，他怎么就不听我的意见呢？” 如果我们自己就对App产品的整个流程的设计和开发有了解、有体验，那该多好；如果我们对彼此的工作有认识、有体会那该多好。 这个原因带给了我创作的灵感。我将通过这本书，向各位设计师、开发者、甚至是普通大众介绍从创意到实现，如何作出一款安卓手机App。 我希望通过这本书，能让即使从来没有设计过App，或者即使从来没有写过安卓程序的你，在看完这本书以后，也能从无到有开发出一款属于你自己的得意之作。 所以这本书针对的读者是： 会安卓编程，但是不会产品设计的开发者； 会产品设计，但是不会编程实现的设计师； 不会安卓编程，也不会产品设计，但是有强烈创作梦想的行动派； 从无到有都有一个过程，淌过这条陌生的河流需要时间、需要坚持、也需要一个好的导师。好的导师能给你指明方向，会给你设计一条到达彼岸的相对捷径，让你少走弯路。让这本书做你的引导者，协助淌过这条河，我相信你今后一定能够顺利的、独立的创造自己的App，能够更好的与伙伴沟通。 } @card{ 怎么读这本书这本书将按照创意 设计 开发 测试 发布这个逻辑顺序设计。每个单元都会讲到原理和实际的运用方法，我将用一个产品作为实际的例子来加深各位读者的印象，让大家能够在实践中获得认识。 在创意单元，我将以自己的深刻体会来谈谈如何发现生活中的创意，如何将创意落实到纸上，头脑风暴怎么做，需求怎么发掘，怎么设计实现的路径。 在设计单元，除了讲解安卓App设计的原理，我还将介绍如何使用Sketch进行产品的原型设计。Sketch是Mac电脑上特有的产品，但是很多的产品设计师还是选择了它，那一定有它的过人之处。假如你使用的是Windows电脑，虽然用不了Sketch，但是设计的原理和方法都是相通的，也很有学习的价值。 开发单元会讲解如何进行代码的管理，如何把之前的设计变成实实在在的代码，如何在真实的设备上实现我们设计的功能。 开发完成，进入测试单元，测试和开发不可分离，它可不想我们想象的那样，在手机上随便按几下按钮就完成了，它可是一个专门的学问，值得单独成为一个大的单元。 最后是发布单元，程序如何打包，如何发布到网络上、发布到应用商店里，发布后如何跟踪应用的bug，都将在这里揭晓。 假如你已经是某个单元的专家了，即使跳过这个单元，也丝毫不会影响你的阅读。 这本书首要的目的是将创意到实现的各个环节都展示出来，然后层层深入。作为新手，你能学到很多使用的知识和技术；作为老鸟，你能站在一定高度来纵览全局。 } @card{ 特点这本书还有几个重要的特点： 对于这本书的创作素材，我会尽量选用最新的内容。 这本书也是一个成长的孩子，我会根据大家的反馈和最新的资讯，不定时的更新其中的内容。请大家通过邮件anddlecn@gmail.com或者QQ群348702074，与我们联系或反馈。 书的内容除了文字以外，我将采用大量的静态图片、动态图片，甚至视频等多媒体手段，为大家阐明书中的内容。 对于书中使用到的工具、示例代码和各种资源文件，也会在我们的官网上提供。 最为重要的是，学习的过程中需要多和志同道合的人交流。为此我组建了QQ群348702074，方便大家的互动和问题解答。 } @card{ 学习的准备工作当然，为了学习这本书的内容，我们还得做好一些物质和精神上的准备， 一个记事本和一杆笔：任何用来做记录的媒介都可以，用它来收集任何时间任何地方得到的产品灵感和创意。 一台电脑：无论是设计还是开发，都离不开电脑，我非常的推荐Mac电脑，Mac非常适合设计师和软件开发者，它能原生的集成很多开发工具，省去了各种搭建环境的麻烦。另外，由于Mac的系统的封闭性，即使遇到问题，也是Mac用户都会遇到的问题，解决办法很单一规范，不像Windows电脑，遇到的问题千奇百怪，解决的方法也可能互不相通。 一部安卓手机：安卓手机上开发App，最好有一台真实的设备，运行起来方便调试，也能随时给朋友展示自己的创意成果。 连续或者分散的时间：不论是整个的寒暑假期，还是周末的全天，甚至是平时上下班的路途，都是学习的宝贵时光。 坚持不懈的努力：最为重要的还是自己的努力和坚持，无论外物如何飘摇，都不能动摇你学习、掌握一项技能的决心，这本书将陪着你，迈出最艰难的第一步。 同学共勉的环境：除了自我的修炼，与同道中人的交流、鼓励也会让我们更快更容易的成长，变得强大。 } @card{ 我的小目标我希望在获得您的反馈帮助后，能完善本书的方方面面，然后集结成书。我也希望这本书能让更多的人知道，让它成为最好的接地气的安卓入门教程。所以也希望借助您的朋友圈，帮我宣传。 } @card{ 关于打赏文章的角落我添加了打赏功能。如果您觉得本系列文章对您很有帮助，在可能的情况下，非常感谢您的鼓励。在您的资助下，我将进一步完善文档的内容，希望很快以其他方式回报于您！ }"},{"title":"从设计到实现","date":"2017-01-29T01:12:26.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"index/index.html","permalink":"http://booktest.anddle.com/index/index.html","excerpt":"","text":"@card{ 展现安卓开发的整个流程用生动的事例，向你展示了一个应用从创意到设计，再到开发，最后直至发布的全部过程。所有的技术要点贯穿于整个产品流程，让学习不再枯燥单调，让你印象深刻。 } @card{ 图文并貌的生动文档用通俗的文字结合生动的图片，讲述着产品开发的所有故事。制作了近千张图片和视频动画，目的只是为了让你能更好理解我想传达给你的每一个细节。 } @card{ 一站式获取开发资源文中所有使用到设计资源和开发图标，我都全部打包呈现。只要你想学并学好，我将为你做好充分的准备，帮助你迈出关键的第一步。 } @card{ 示例代码的参考除了照着文档从头到尾实现你的第一个安卓应用；也可以通过我托管到Github上的源码进行对比学习。掌握一项代码管理的工程技能，对你的帮助将十分巨大。 } @card{ 适合阅读本系列文章的人群 @column-2{ @card{ 大学生大学时光充满了活力、激情与好奇心，不幸的是对技术感兴趣却没有人带路。我保证只要你按照文档中讲到的内容一步一步照着做，一个月的时间定让你脱胎换骨。当其他同学对前路还一片迷茫的时候，你已经来到了充满了新奇与未知的全新领域。 } @card{ 开发者已经有经验的开发者也很适合这系列的文章。它将你的视野从眼前挪开，从设计者的角度看问题。为什么设计师要如此设计？为什么我开发的安卓代码是这个样子？问题的答案都放在本系列文章的各个角落当中。 } } @column-2{ @card{ 设计师界面设计师常常苦恼自己设计出来的作品永远停留在概念阶段：要么自己设计的太超前，不接地气；要么自己没有能力去实现它。我保证，设计师把本系列文章做完之后，一定会重新认识一遍设计的工作，将设计的能力延展到实践当中，更好的与别人合作。 } @card{ 产品经理优秀的产品经理除了要能提出一款出色产品概念，更需要能将它们变成现实的高瞻远瞩。要与聪明的设计师与开发者打交道，最好能理解他们的所思所想，站在他们的角度去看看产品。了解他们的最好办法，就是通过一个简单的案例，把大家的角色都模拟一遍。 } } } @card{ 交流方式QQ群：348702074我们开通了这个QQ群，希望大家能够通过它互相讨论，在学习上互相帮助，取得更快的进步；也希望借此能得到大家对本系列文章的反馈，得到各位的呵护，让它茁壮成长。 } @card{ 成书计划等到本系列文章全部完成以后，我计划将它整理成书，提供给更多的希望了解安卓应用开发的读者学习和参考。希望大家能多多给予反馈，让它出生的时候尽可能的全面而完善。 @timeline{ 2017@item{ 6月计划整理文档成书。 } @item{ 6月计划发布软件发布相关的文章内容。 } @item{ 5月计划发布软件测试相关的文章内容。 } @item{ 4月计划发布软件开发相关的文章内容。 } @item{ 3月计划发布设计实践相关的文章内容。 } @item{ 2月发布设计理论相关的文章内容。 } } } @card{ 关于打赏如果您觉得本系列文章对您很有帮助，在可能的情况下，非常感谢您的鼓励。在您的资助下，我将进一步完善文档的内容，希望很快以其他方式回报于您！ @column-2{ @card{ 通过微信支持 } @card{ 通过支付宝支持 } } }"},{"title":"资源下载","date":"2017-01-30T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"resources/index.html","permalink":"http://booktest.anddle.com/resources/index.html","excerpt":"","text":"@card{ 资源下载 项目 下载地址 说明 Sketch素材 下载 提供天气预报界面会用到的各种矢量图 Sketch静态产品原型 下载 Sketch开发完成后的静态原型 Origami动态产品原型 下载 Origami开发完成后的动态可交互原型 安卓应用图标素材 下载 使用Android Studio开发时会使用到的各种图标 } @card{ 项目源码天气预报应用，已经托管到了GitHub上。使用GitHub可以学会如何对代码进行管理，能看到整个项目开发逐渐的演变过程。 点击这里。 } @card{ 设计工具 工具名称 下载地址 说明 Sketch 官方地址 云盘下载 只支持MacOS，付费软件，这里提供的是试用版 Origami 官方下载 云盘下载 只支持MacOS Sketch官方地址：这里Origami官方地址：这里 } @card{ Android StudioAndroid应用开发的官方集成开发环境。 版本号 Windows Mac Linux 2.2.2 官方下载 云盘下载 官方下载 云盘下载 官方下载 云盘下载 2.1.3 官方下载 云盘下载 官方下载 云盘下载 官方下载 云盘下载 1.5.1 官方下载 云盘下载 官方下载 云盘下载 官方下载 云盘下载 *Window下载包集成了Android Studio和Android SDK 官方地址：这里 } @card{ Oracle JDKAndroid Studio与Android SDK依赖的JAVA开发环境。 版本号 Windows 64bit Windows 32bit Mac Linux 64bit Linux 32bit JDK8 官方下载 云盘下载 官方下载 云盘下载 官方下载 云盘下载 官方下载 云盘下载 官方下载 云盘下载 官方地址：这里 }"},{"title":"categories","date":"2017-02-01T00:41:38.000Z","updated":"2017-02-04T09:04:19.000Z","comments":false,"path":"categories/index.html","permalink":"http://booktest.anddle.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-01T00:41:23.000Z","updated":"2017-02-04T09:04:19.000Z","comments":false,"path":"tags/index.html","permalink":"http://booktest.anddle.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"18 调整列表显示","slug":"4_开发/18_调整列表显示","date":"2017-02-12T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/18_调整列表显示/","link":"","permalink":"http://booktest.anddle.com/4_开发/18_调整列表显示/","excerpt":"","text":"调整列表显示现在界面上列表的异常显示根本原因在于：将ListView放到了NestedScrollView之内。NestedScrollView内部要使用列表的话，必须使用RecyclerView。 RecyclerView是我们之前提到的Material Design开发支持库中的一个。从它的名字可以看出，它的优点在于提高了数据项刷新、滚动的效率，减小了系统资源的占用。听起来有点抽象是吧，那就记住它的效率更高就行了，实现的原理我们就不去深究了。 使用RecyclerView之前我们要确定它是否已经被加载到了项目中。 由于之前我们已经添加了设计支持库-compile &#39;com.android.support:design:24.2.1&#39;，所以RecyclerView所使用的com.android.support:recyclerview-v7:24.2.1也已经被自动加载。 替换ListView将activity_main.xml中原来的ListView，用RecyclerView替换， 123456789101112131415161718192021&lt;android.support.v4.widget.NestedScrollView ......&gt; &lt;LinearLayout ......&gt; ...... &lt;View ....../&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/weather_more_info_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/android.support.v7.widget.RecyclerView&gt; &lt;/LinearLayout&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 修改MainActivity.java中关于原来ListView的部分， 12345678910111213141516171819public class ScrollingActivity extends AppCompatActivity &#123; private RecyclerView mWeatherMoreInfoListView; ...... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ...... mWeatherMoreInfoListView = (RecyclerView) findViewById(R.id.weather_more_info_list); LinearLayoutManager layoutManager = new LinearLayoutManager(MainActivity.this); mWeatherMoreInfoListView.setLayoutManager(layoutManager); ...... &#125; ......&#125; 重新设计Adapter我们将ListView替换成了RecyclerView，那么它们各自对应的Adapter也需要做些调整。RecyclerView需要与继承自RecyclerView.Adapter的Adapter配合使用。定义个WeatherMoreInfoAdapter， 让WeatherMoreInfoAdapter继承自RecyclerView.Adapter，并重写3个必须实现的接口， 1234567891011121314151617public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return null; &#125; @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; &#125; @Override public int getItemCount() &#123; return 0; &#125;&#125; 增加Adapter的构造函数，让它能保持传入的要显示的数据项， 12345678910public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; private List&lt;WeatherMoreInfo&gt; mData; public WeatherMoreInfoAdapter(List&lt;WeatherMoreInfo&gt; data) &#123; this.mData = data; &#125; ......&#125; getItemCount()要返回当前数据的项数， 123456789public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; ...... @Override public int getItemCount() &#123; return mData.size(); &#125;&#125; RecyclerView之所以能够提高运行效率，最主要的原因是它依靠一个Holder保存了对数据项界面中各个布局的引用，每次更新界面的时候，不需要再去findViewById()了。 所以我们要： 定义一个ViewHolder，让它继承自RecyclerView.ViewHolder， 1234567public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; public class ViewHolder extends RecyclerView.ViewHolder &#123; &#125; ......&#125; 将数据项的布局在首次创建的时候保存起来，避免下次重复findViewById()，提高效率， 123456789101112131415161718public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; public class ViewHolder extends RecyclerView.ViewHolder &#123; public ImageView icon; public TextView description; public TextView value; public ViewHolder(View v) &#123; super(v); this.icon = (ImageView) v.findViewById(R.id.weather_more_info_icon); this.description = (TextView) v.findViewById(R.id.weather_more_info_description); this.value = (TextView) v.findViewById(R.id.weather_more_info_value); &#125; &#125; ......&#125; 当WeatherMoreInfoAdapter需要创建数据项界面的时候就会自动触发onCreateViewHolder()的调用，获取一个ViewHolder。 因此我们需要在这里创建布局界面，并把界面元素缓存到ViewHolder里面， 12345678910111213public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; ...... @Override public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View v = LayoutInflater.from(parent.getContext()) .inflate(R.layout.weather_more_info_item_layout, parent, false); ViewHolder vh = new ViewHolder(v); return vh; &#125;&#125; Adapter更新数据是，会触发onBindViewHolder()，让我们更新界面， 从mData取出要显示的数据； 将RecyclerView.ViewHolder转换成我们自定义的ViewHolder； 设置数据到界面元素上； 1234567891011121314public class WeatherMoreInfoAdapter extends RecyclerView.Adapter &#123; ...... @Override public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123; WeatherMoreInfo info = mData.get(position); ViewHolder viewHolder = (ViewHolder) holder; viewHolder.icon.setImageResource(info.typeResId); viewHolder.description.setText(info.description); viewHolder.value.setText(info.value); &#125;&#125; 至此新的Adapter就设计完成了。 使用WeatherMoreInfoAdapter根据新实现的WeatherMoreInfoAdapter，修改使用它的方法， 123456789101112131415161718public class ScrollingActivity extends AppCompatActivity &#123; private RecyclerView mWeatherMoreInfoListView; ...... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ...... mWeatherMoreInfoList = new ArrayList&lt;&gt;(); WeatherMoreInfoAdapter adapter = new WeatherMoreInfoAdapter(mWeatherMoreInfoList); mWeatherMoreInfoListView.setAdapter(adapter); ...... &#125; ......&#125; 将程序运行看看， 我们的天气应用似乎已经开发完成了！！！ 最后千万别忘记我在代码中留下的种种bug，我们将在后面的单元-关于测试章节将这些bug都找出来。让它成为真正可用的应用程序。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"17 Appbar动效","slug":"4_开发/17_Appbar动效","date":"2017-02-11T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/17_Appbar动效/","link":"","permalink":"http://booktest.anddle.com/4_开发/17_Appbar动效/","excerpt":"","text":"Appbar动效之前的改造完成后，Appbar还不能具有滑动的效果。 要具备联动的滑动功能，还需要做3个地方的修改。 使用CoordinatorLayoutCoordinatorLayout是Material Design里面，所有滑动渐变效果必用的布局，它能根据内部某个元素滑动的百分比来控制内部另一个元素的属性变化。 要实现Appbar随着界面滑动而进行变化， 必须引入CoordinatorLayout，使之替换activity_main.xml中，最外层的那个LinearLayout， 1234567891011121314151617&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.anddle.weatherapp.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout ......&gt; ...... &lt;/android.support.design.widget.AppBarLayout&gt; ...... &lt;/android.support.design.widget.CoordinatorLayout&gt; 给CollapsingToolbarLayout，增加app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;属性， 1234&lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; 这两个属性说明要让Appbar可以滑动，并且Appbar完全折叠起来后，Toolbar要能够显示出来（假如没有设置exitUntilCollapsed，Toolbar是可以被完全折叠隐藏起来的）。 使用NestedScrollView使用CoordinatorLayout之后可以看到，整个界面变形了，天气预报区域和更多天气信息区域整体向上移动到了顶部重叠起来。 这是因为CoordinatorLayout本质上是个FrameLayout，它内部的组件当然会堆叠起来。 要解决这个问题就要NestedScrollView出场了。它能向LinearLayout一样将组件按照顺序竖直排列。并且与AppBarLayout形成联动。 NestedScrollView的内部只能放一个子布局或者控件，所以必须把天气预报区域和更多天气信息区域做成一个整体，放进一个LinearLayout中， 1234567891011121314151617181920212223242526272829303132333435&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;!--原有的布局--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"@dimen/forcast_height\" android:orientation=\"horizontal\" android:layout_marginLeft=\"@dimen/forcast_margin\" android:layout_marginRight=\"@dimen/forcast_margin\"&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item1\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item2\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item3\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item4\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item5\" /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"@dimen/gap_height\" android:background=\"#1F000000\" /&gt; &lt;ListView android:id=\"@+id/weather_more_info_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 将刚创建的LinearLayout放到NestedScrollView中， 1234567891011121314&lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; ...... &lt;/LinearLayout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt; 为NestedScrollView添加属性app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;， 12345678&lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; ...... &lt;/android.support.v4.widget.NestedScrollView&gt; appbar_scrolling_view_behavior这个值是Android SDK提供的一个现成的取值。我们暂时只要知道这里必须这样使用就好了。要理解它深层次的含义，必须要系统的讲解CoordinatorLayout的设计思路。这个设计思路我会在将来的专题中去讲，现在大家就先记住使用它的结论吧。 运行看看效果， 更新地理位置使用了设计支持库后，地理位置信息不需要单独的布局文件了。它会作为应用的名称进行展示。 所以在更新地理位置的时候，我们只需要更新应用的名称就行。 给activity_main.xml中的CollapsingToolbarLayout增加一个id-collapsing_layout，便于我们在java代码中获取到它； 12345&lt;android.support.design.widget.CollapsingToolbarLayout android:id=\"@+id/collapsing_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; 打开MainActivity.java源码文件，修改updateWeatherDetail()函数，使用CollapsingToolbarLayout的setTitle()方法修改应用的标题； 12345678910private void updateWeatherDetail(String location, String temperature, String temperatureRange, int weatherCode) &#123; ...... currentTemperatureView.setText(temperature); temperatureRangeView.setText(temperatureRange); CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_layout); collapsingToolbar.setTitle(location); ......&#125; 至此，Appbar的滑动效果就完成了。不过大家也能看到，这里引入了一个新的问题：列表内容显示不正确，只有第一项的内容。 这个问题我们在下一节来解决。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"16 改造Appbar","slug":"4_开发/16_改造Appbar","date":"2017-02-10T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/16_改造Appbar/","link":"","permalink":"http://booktest.anddle.com/4_开发/16_改造Appbar/","excerpt":"","text":"改造Appbar现在我们开始改造Appbar，希望给它添加上滑动效果， Appbar改造方案根据Material Design规范，Appbar可以由3个区域组成， 天气预报应用会使用到3个区域中的Toolbar和Flexible space。 它们的对应关系，可以使用Android SDK提供的设计支持库来实现， 区域 支持库控件 高度 说明 Appbar android.support.design.widget.AppBarLayout 300dp 包含Toolbar和可变区域 Appbar android.support.design.widget.CollapsingToolbarLayout 300dp 为了Toolbar和可变区域能配合滑动 Toolbar android.support.v7.widget.Toolbar 56dp 显示位置信息 Flexible area LinearLayout 300dp 放置天气详情 其中， 在AppBarLayout里面又放入了一个CollapsingToolbarLayout-可以折叠Toolbar的布局。CollapsingToolbarLayout能够让内部的Toolbar和可变区域能配合着滑动，出现设计中的滑动折叠效果。 Flexible area可变区域中的内容，就是天气详情界面。 Appbar布局的调整移除地理位置： 设计支持库提供的CollapsingToolbarLayout支持中，自动包含了我们之前设计的地理位置信息的展示区域-也就是显示应用的标题。所以我们， 将它的布局从之前的布局文件中移除； 修改MainActivity.java的updateWeatherDetail()函数，将涉及到weather_location的代码移除； 123456789101112private void updateWeatherDetail(String location, String temperature, String temperatureRange, int weatherCode) &#123; TextView currentTemperatureView = (TextView) findViewById(R.id.current_temperature); TextView temperatureRangeView = (TextView) findViewById(R.id.temperature_range); ImageView weatherIcon = (ImageView) findViewById(R.id.weather_icon); currentTemperatureView.setText(temperature); temperatureRangeView.setText(temperatureRange); int iconId = R.mipmap.ic_sunny_cloudy_l; ......&#125; 添加Appbar： 将高度原本设置成244dp的LinearLayout修改成AppBarLayout，让它包裹整个天气详情布局； 高度调整为300dp，移除背景颜色和不需要的orientation属性； 12345678&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"300dp\"&gt; &lt;!--天气详情的布局--&gt; ...... &lt;/android.support.design.widget.AppBarLayout&gt; 添加CollapsingToolbarLayout：在AppBarLayout内，增加CollapsingToolbarLayout，让它包裹整个天气详情布局； 1234567891011121314&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"300dp\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!--天气详情的布局--&gt; ...... &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 添加Toolbar： 在CollapsingToolbarLayout内，增加Toolbar，让它与整个天气详情布局处于平级； 给Toolbar设置id-app_toolbar; 高度设置成&quot;?attr/actionBarSize&quot;，这是Android SDK提供的一个值，表示的就是Appbar的高度-56dp； 12345678910111213141516171819&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"300dp\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/app_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\"/&gt; &lt;!--天气详情的布局--&gt; ...... &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; ?attr/actionBarSize&quot;当中?的用法表示：这个属性的取值，与当前应用使用的到的actionBarSize属性的取值相同；但是actionBarSize取值到底是什么，我们并不需要知道，只要知道系统对这个值有设定就行了，我们的目的是让它与系统值保持一致即可。 修改天气详情布局的上边距： 将上边距从24dp调整为80dp， 12345678910111213141516171819202122232425262728&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"300dp\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/app_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\"/&gt; &lt;!--天气详情的布局--&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"80dp\" android:orientation=\"horizontal\" android:gravity=\"center\"&gt; ...... &lt;/LinearLayout&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;&lt;/android.support.design.widget.AppBarLayout&gt; 现在Appbar的布局就调整好了。 启用Toolbar我们在布局文件中，使用了Toolbar，希望借此代替程序原有的标题栏。 但代替的工作还没有完成。 还需要做两件配合的事情。 代码设置在MainActivity创建的时候，我们需要， 通过findViewById()找到布局文件中的Toolbar； 使用setSupportActionBar()替换系统默认的标题栏； 1234567891011121314public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"TEST\", \"Weather app launched\"); Toolbar toolbar = (Toolbar) findViewById(R.id.app_toolbar); setSupportActionBar(toolbar); ...... &#125; ......&#125; 此时运行程序看看吧。啊哦！！！程序运行崩溃了， 当程序运行出错的时候，设备通常会弹出这样的对话框，提示用户。不过这个提示对开发者没有太大的用处，没法知道哪里出错了。 再看看Android Studio的调试窗口(Android Monitor -&gt; logcat)，打出了一堆的信息， 通过打出的信息，我们可以看到，系统提示我们要使用Toolbar的话，必须将主题的windowActionBar设置成false。 这是啥意思？主题又是啥？ 主题设置主题是一个应用或者Activity的显示风格，它的定义和前面提到的style很类似。先跟着我做一遍，之后你一定会对主题有个具体的认识， 打开res\\valuse\\styles.xml文件，里面已经默认定义好了一个主题AppTheme; 自定义一个主题-AppTheme.NoActionBar； 123456789101112131415161718&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name=\"AppTheme.NoActionBar\"&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;/style&gt; ...... &lt;/resources&gt; AppTheme.NoActionBar的这种写法，说明它继承了主题AppTheme的所有属性。 这个新主题，新增了windowActionBar为false，和windowNoTitle为true两个属性。 通过.分割主题名称的命名方式，是主题的隐性继承，还有一种使用parent=的显性继承方式，例如AppTheme的定义。 使用这个主题的时候，需要， 打开AndroidManifest.xml文件， 修改Activity的属性，给它加上android:theme=&quot;@style/AppTheme.NoActionBar&quot;， 123456789&lt;application ...... android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\" android:theme=\"@style/AppTheme.NoActionBar\"&gt; ...... &lt;/activity&gt; &lt;/application&gt; 这样一来，MainActivity就使用了我们刚定义的AppTheme.NoActionBar主题。 同时也可以看到整个程序-application，在默认情况下使用的是AppTheme主题。 再次运行程序看看，成了，程序没有报错了。 不过这里会发现2个问题： 天气预报几个字是黑色，与我们预想的不符； 滑动整个界面，还是没有Appbar动态变化的效果； 我们先来解决第1个问题。 天气预报这几个字，默认情况下是程序的名称，是AppBarLayout自身就有的一部分。 因此可以给AppBarLayout设置一个显示白色文字的主题。 Android SDK提供了很多现成的主题，这里可以使用一个叫做ThemeOverlay.AppCompat.Dark.ActionBar的主题。 1234&lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; 为什么是选择的这个主题？ 这个主题能让文字从黑色变成白色，其他文字的属性都不会被影响； 用多了就习惯了； 要解决第2个问题，我们还的继续调整整个界面的布局。 咱们下一节继续。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"15 MaterialDesign开发","slug":"4_开发/15_MaterialDesign开发","date":"2017-02-09T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/15_MaterialDesign开发/","link":"","permalink":"http://booktest.anddle.com/4_开发/15_MaterialDesign开发/","excerpt":"","text":"Material Design开发从这一章节开始，我们将开始把现有的设计改造成Material Design。 前面我们已经详细的介绍过了Material Design设计相关的内容，但是具体落实到实际的开发，又需要考验程序开发者了。 Google深知实现Material Design对于初级开发者的难度。为了让开发者们能尽可能的使用Material Design规范开发应用，它提供了一系列的开发支持库， 支持库名称 例子 设计支持库 com.android.support:design:24.2.1 v7 appcompat 库 com.android.support:appcompat-v7:24.2.0 v7 cardview 库 com.android.support:cardview-v7:24.2.0 v7 gridlayout 库 com.android.support:gridlayout-v7:24.2.0 v7 palette 库 com.android.support:palette-v7:24.2.0 v7 recyclerview 库 com.android.support:recyclerview-v7:24.2.0 这些支持库是对Android SDK的拓展，实现了很多复杂的Material Design动态效果。开发者不需要去为如何实现一个动效而抓耳挠腮，只需要把精力放倒程序逻辑当中。 这些开发包具体支持了哪些Material Design的设计呢？下面举几个例子， 悬浮按钮（Floating Action bar） Appbar可滑动的界面特效（CoordinatorLayout） 侧边栏滑动 支持包的用法看到这么多支持库，是不是有点犯晕，不知道该用哪个，具体怎么使用了？ 现在开始改造天气预报，给工程添加Material Design的支持库。 Android Studio给我们提供了一个非常简便的方法， 打开项目工程下的app\\build.grandle目录（注意是app目录下的build.grandle文件）， 给dependencies添加支持库的引用，compile &#39;com.android.support:design:24.2.1&#39; 123456789dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) androidTestCompile('com.android.support.test.espresso:espresso-core:2.2.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;) compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:design:24.2.1' testCompile 'junit:junit:4.12'&#125; 其中的compile &#39;com.android.support:appcompat-v7:24.2.1&#39;是原本就有的，假如没有，只是添加compile &#39;com.android.support:design:24.2.1&#39;也行，Android Studio会自动加上设计支持库需要的库文件。 保存修改后，点击右上角出现的Sync Now就可以了， 可以看到，整个项目多出了如下的java包， 引入设计支持库的时候，Android Studio还会检查是否已经引入了其他相关支持库，如果没有会自动引入，例如很多v4和v7的支持包。 假如要使用没有自动引入的开发库，我们需要使用上面的方法，手动引入支持库。例如v7 palette 库， 1234567dependencies &#123; ...... compile 'com.android.support:appcompat-v7:24.2.1' compile 'com.android.support:design:24.2.1' compile 'com.android.support:palette-v7:24.2.0' testCompile 'junit:junit:4.12'&#125; Google提供的官方支持库，包含了很多种类，开发者需要根据自己的需要自己选择。最重要的就是v4支持库（由多个支持库组成） v7支持库由多个支持库组成）和设计支持库。通常来讲只要引入设计支持库，就能自动引入很多常用的相关开发库了。 支持库就是aar格式的文件，把它解压后可以发现，里面包含了开发需要使用到的jar包、资源文件等等。不过你并不需要自己去找这样的aar文件，Android Studio会自动为你完成匹配。 配色方案在前面的设计原理章节，我们讲到了Material Design有一个色彩搭配的规则：一个应用要设定它的调色板，Primary Color Primary Dark Color Accent Color。 这个规则在代码实现中是如何得以体现的呢？ 我们打开项目工程的app\\src\\main\\res\\values\\colors.xml，可以看到这样的颜色定义， 12345&lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt;&lt;/resources&gt; 这三个颜色正是对应着调色板的三个主要颜色， 调色板块 颜色属性名称 调色板颜色名 颜色值 Primary Color colorPrimary Indigo 500 #3F51B5 Primary Dark Color colorPrimaryDark Indigo 700 #303F9F Accent Color colorAccent Pink A200 #FF4081 在打开项目工程的app\\src\\main\\res\\values\\styles.xml，可以看到这样的颜色定义， 1234567891011&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.DarkActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; ......&lt;/resources&gt; 可以看到，这里定义了一个主题AppTheme。 主题theme是一个应用或者Activity的显示风格，它的定义和前面提到的style很类似。 这个主题当中，重新定义了主题的colorPrimary colorPrimaryDark colorAccent属性，把调色板的颜色赋予给了它们。 又在AndroidManifest.xml当中把这个主题赋予了整个应用， 1234567891011&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.anddle.weatherapp\"&gt; ...... &lt;application ...... android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; ...... &lt;/application&gt;&lt;/manifest&gt; 上面整个这套配色体系在工程创建的时候，就自动为我们创建好了。所以在进入这一章节之前，将应用运行起来的时候，已经可以看到天气预报界面这样的颜色搭配了。 假如你对主题theme还是感觉很抽象没有明白，也没有关系，后面我们会自定一个主题，我想等你做过一遍后，会对它有一个具体的认识与理解。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"14 界面优化","slug":"4_开发/14_界面优化","date":"2017-02-08T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/14_界面优化/","link":"","permalink":"http://booktest.anddle.com/4_开发/14_界面优化/","excerpt":"","text":"界面优化天气预报的功能都实现了，但代码当中还有一些需要优化的地方。比如对资源的使用方式。 style的用法假如我们想要修改当日温度的字体属性，那就需要修改activity_main.xml中current_temperature所对应的字体颜色、大小等参数。 修改的方案有2个： 直接修改TextView对应的android:textColor android:textSize等属性； 给TextView设置一个style，将希望的属性都放到这个Style当中； 作为优化的方式，我们当然选择第2种方案：使用Style。可以将使用这种类型的字体都统一起来，如果需要修改这些文字的样式，只要修改这种Style就可以了，大大减小了编码的工作量，便于后期维护。 首先来改造一下天气详情当中的当前温度， 打开res\\values\\styles.xml文件； 将android:textColor android:textSize等特性定义成一个style－－－`WeatherDetailCurrentTemperatureStyle。 1234567&lt;resources&gt; ...... &lt;style name=\"WeatherDetailCurrentTemperatureStyle\"&gt; &lt;item name=\"android:textColor\"&gt;#b3ffffff&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;56sp&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; android:textColor android:textSize的取值，完全与current_temperature中的设置完全相同； 为TextView设置android:textAppearance属性，添加WeatherDetailCurrentTemperatureStyle风格； 123456&lt;TextView android:id=\"@+id/current_temperature\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"23°\" android:textAppearance=\"@style/WeatherDetailCurrentTemperatureStyle\"/&gt; 使用类似的方法，我们可以添加更多的style，将它们应用到对应的TextView中， style名称 应用的对象 所在文件 WeatherDetailCurrentTemperatureStyle current_temperature activity_main.xml WeatherDetailTemperatureRangeStyle temperature_range activity_main.xml WeatherDetailLocationStyle weather_location activity_main.xml WeatherForcastDateStyle forcast_date forcast_item.xml WeatherForcastTemperatureRangeStyle forcast_temperature forcast_item.xml WeatherMoreInfoDescriptionStyle weather_more_info_description weather_more_info_item_layout.xml WeatherMoreInfoValueStyle weather_more_info_value weather_more_info_item_layout.xml 资源优化字符串、颜色以及各种尺寸相关的值都属于程序的资源。我们前面都是直接使用的这些资源，例如, 1234567&lt;resources&gt; ...... &lt;style name=\"WeatherForcastTemperatureRangeStyle\"&gt; &lt;item name=\"android:textColor\"&gt;#8a000000&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;12sp&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 其实这些资源可以分门别类的放到单独的位置定义，然后通过@引用的方式进行使用。 优化颜色颜色的定义和使用， 颜色应该定义到res\\values\\colors.xml当中， 123&lt;resources&gt; &lt;color name=\"colorBlackDarkText\"&gt;#DE000000&lt;/color&gt;&lt;/resources&gt; 在需要使用它的地方采用引用的方式，@color/， 1234&lt;style name=\"WeatherMoreInfoDescriptionStyle\"&gt; &lt;item name=\"android:textColor\"&gt;@color/colorBlackDarkText&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;16sp&lt;/item&gt;&lt;/style&gt; 使用类似的方法，我们可以添加更多的color，将它们应用到对应的地方， 颜色值 颜色名称 所在文件 #DE000000 colorBlackDarkText 凡事使用了该颜色的位置 #8A000000 colorBlackLightText 凡事使用了该颜色的位置 #FFFFFFFF colorWhiteLightText 凡事使用了该颜色的位置 #b3FFFFFF colorWhiteDarkText 凡事使用了该颜色的位置 1234567891011&lt;resources&gt; &lt;color name=\"colorPrimary\"&gt;#3F51B5&lt;/color&gt; &lt;color name=\"colorPrimaryDark\"&gt;#303F9F&lt;/color&gt; &lt;color name=\"colorAccent\"&gt;#FF4081&lt;/color&gt; &lt;color name=\"colorBlackDarkText\"&gt;#DE000000&lt;/color&gt; &lt;color name=\"colorBlackLightText\"&gt;#8A000000&lt;/color&gt; &lt;color name=\"colorWhiteLightText\"&gt;#FFFFFFFF&lt;/color&gt; &lt;color name=\"colorWhiteDarkText\"&gt;#b3FFFFFF&lt;/color&gt;&lt;/resources&gt; 优化尺寸之前给控件或者布局设置边距的时候，都是直接写的xxdp。这个数值最好也统一放倒资源文件当中进行统一管理， 尺寸应该定义到res\\values\\dimens.xml当中， 1234&lt;resources&gt; ...... &lt;dimen name=\"forcast_margin\"&gt;16dp&lt;/dimen&gt;&lt;/resources&gt; 在需要使用它的地方采用引用的方式，@dimen/， 1234567891011121314&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:orientation=\"horizontal\" android:layout_marginLeft=\"@dimen/forcast_margin\" android:layout_marginRight=\"@dimen/forcast_margin\"&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item1\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item2\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item3\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item4\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item5\" /&gt;&lt;/LinearLayout&gt; 使用类似的方法，我们可以添加更多的color，将它们应用到对应的地方， 数值 数值名称 所在文件 16dp forcast_margin activity_main.xml 10dp gap_height activity_main.xml 100dp forcast_height activity_main.xml 16dp list_icon_left_margin weather_more_info_item_layout.xml 72dp list_text_left_margin weather_more_info_item_layout.xml 16dp list_text_right_margin weather_more_info_item_layout.xml 123456789101112&lt;resources&gt; &lt;!-- Default screen margins, per the Android Design guidelines. --&gt; &lt;dimen name=\"activity_horizontal_margin\"&gt;16dp&lt;/dimen&gt; &lt;dimen name=\"activity_vertical_margin\"&gt;16dp&lt;/dimen&gt; &lt;dimen name=\"forcast_margin\"&gt;16dp&lt;/dimen&gt; &lt;dimen name=\"forcast_height\"&gt;100dp&lt;/dimen&gt; &lt;dimen name=\"gap_height\"&gt;10dp&lt;/dimen&gt; &lt;dimen name=\"list_icon_left_margin\"&gt;16dp&lt;/dimen&gt; &lt;dimen name=\"list_text_left_margin\"&gt;72dp&lt;/dimen&gt; &lt;dimen name=\"list_text_right_margin\"&gt;16dp&lt;/dimen&gt;&lt;/resources&gt; 优化字符串当应用启动后，还没有获取到网络数据的时候，界面上应该显示空数据才行，不然很容易误导用户。 在之前的开发中，我为了在布局的时候能够看到界面效果，所以写入了很多假的信息。这里需要一一挪除了。对于文字的部分，如果没有显示我们就统一使用-来代替， 原始文字 空数据文字 23° –° 17℃～25℃ -℃～-℃ 成都 – 星期X — 字符串应该统一定义到res\\values\\strings.xml当中， 123&lt;resources&gt; &lt;string name=\"current_temperature_none\"&gt;--°&lt;/string&gt;&lt;/resources&gt; 在使用它的地方用@string/来引用， 123456&lt;TextView android:id=\"@+id/current_temperature\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/current_temperature_none\" android:textAppearance=\"@style/WeatherDetailCurrentTemperatureStyle\"/&gt; 使用类似的方法，我们可以添加更多的string，将它们应用到对应的地方， 字符串 字符串名称 所在文件 –° current_temperature_none activity_main.xml -℃～-℃ temperature_range_none activity_main.xml forcast_item.xml – location_none activity_main.xml — date_none forcast_item.xml 对于在代码中使用字符串，应该采用如下方式， 1String str = context.getString(R.string.current_temperature_none); 其中context是一个应用到上下文环境。对一个Activity来说，就是Activity自身MainActivity.this。 设置字符串的时候，也可以直接使用字符串对应的资源id， 12TextView currentTemperatureView = (TextView) findViewById(R.id.current_temperature);currentTemperatureView.setText(R.string.current_temperature_none); 项目工程中WeatherMoreInfo.java中使用了字符串，所以需要将这里的字符串进行改造， strings.xml中增加对应的文字： 1234567891011&lt;resources&gt; ...... &lt;string name=\"wind_direction\"&gt;Wind Direction&lt;/string&gt; &lt;string name=\"wind_level\"&gt;Wind Level&lt;/string&gt; &lt;string name=\"humidity_level\"&gt;Humidity&lt;/string&gt; &lt;string name=\"air_quality\"&gt;Air Quality&lt;/string&gt; &lt;string name=\"sport\"&gt;Sport&lt;/string&gt; &lt;string name=\"ultraviolet_level\"&gt;Ultraviolet&lt;/string&gt;&lt;/resources&gt; WeatherMoreInfo.java中的description类型从String改变成int， 12345678910111213141516171819202122232425262728293031323334353637383940414243public class WeatherMoreInfo &#123; ...... public int description; public WeatherMoreInfo(String keyword, String value) &#123; this.value = value; switch (keyword) &#123; case \"wind_direction\": this.typeResId = R.mipmap.ic_wind_direction; this.description = R.string.wind_direction; break; case \"wind_level\": this.typeResId = R.mipmap.ic_wind_level; this.description = R.string.wind_level; break; case \"humidity_level\": this.typeResId = R.mipmap.ic_humidity_level; this.description = R.string.humidity_level; break; case \"air_quality\": this.typeResId = R.mipmap.ic_air_quality; this.description = R.string.air_quality; break; case \"sport_level\": this.typeResId = R.mipmap.ic_sport_level; this.description = R.string.sport; break; case \"ultraviolet_ray\": this.typeResId = R.mipmap.ic_ultraviolet_level; this.description = R.string.ultraviolet_level; break; &#125; &#125;&#125; 将代码中所有使用资源的地方，都按照前面介绍的方式进行改造。以后在修改代码的时候，就不会牵一发而动全身了，只需要修改一处，就能够把所有需要修改的地方都修改到了。 重新运行程序，可以看到这样的界面了， 现在资源使用方式的优化就完成了。 多国语言支持安卓系统，支持多国语言。它的本质是使用资源的命名法在res\\目录下，增加一个value-xx目录，然后在里面添加string.xml文件，该文件当中定义的字符串就是当地的语言。 例如增加中文支持，就增加一个名字叫做value-zh的目录。添加string.xml文件后，就该文件当中定义的中文字符串。 现在我们将添加对中文支持。 在res目录下，点击右键，启动创建android resource的向导； 在File name栏，输入strings，再选中下方的locale，添加到右边； 选中zh，代表中文； 在创建出来的中文的res\\values-zh\\strings.xml文件中，仿照res\\values\\strings.xml的内容，添加中文语言； 1234567891011 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"app_name\"&gt;天气预报&lt;/string&gt; &lt;string name=\"wind_direction\"&gt;风向&lt;/string&gt; &lt;string name=\"wind_level\"&gt;风力&lt;/string&gt; &lt;string name=\"humidity_level\"&gt;湿度&lt;/string&gt; &lt;string name=\"air_quality\"&gt;空气质量&lt;/string&gt; &lt;string name=\"sport\"&gt;运动&lt;/string&gt; &lt;string name=\"ultraviolet_level\"&gt;紫外线&lt;/string&gt;&lt;/resources&gt; 这里的app_name，在AndroidManifest.xml文件中被使用，里面使用了android:label属性，指定这个应用的名称。 1234567891011121314&lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; 现在天气预报就支持了中文和英文显示了。 至此我们也完成了整个第一阶段的任务：开发完成了天气预报的所有功能。我们将在下一个阶段开始，加入Material Design的设计。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"13 获取网络数据","slug":"4_开发/13_获取网络数据","date":"2017-02-07T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/13_获取网络数据/","link":"","permalink":"http://booktest.anddle.com/4_开发/13_获取网络数据/","excerpt":"","text":"获取网络数据之前对数据的解析都是建立在假数据之上的，当网络端的开发者把真实数据上线以后，我们就可以通过网络获取真实的数据了。 正如我们最早的假设前提那样，网络数据是由我构造好了放到自己的服务器上的，里面的内容并不是真实的当日天气，只是便于大家学习如何使用网络访问获取数据。 我们这个示例的网络地址是：http://book.anddle.com/api/query_weather。 大家通过浏览器打开，可以看到它包含的内容与我们之前写死在代码中的内容完全一致。 很多时候访问网络数据还需要传入访问的参数，就像我们使用java语言中的函数调用一样，同一个接口需要很多的参数。比如，我们这个天气信息的请求，可以携带地理位置的参数， 1http://book.anddle.com/api/query_weather?location=北京&amp;date=2017-01-01 尾部的?表示后面携带的都是参数，location=北京&amp;date=2017-01-01就是携带的参数。 这些参数成键值对的形式出现，用=分割-location=北京 date=2017-01-01； 参数之间用&amp;分割； 我们这里很简单，没有提供参数，只需要使用http://book.anddle.com/api/query_weather发出查询请求就可以了。 准确的来讲，我们这里使用的都是http的GET方法获取数据，还有一种POST方法。POST方法不会在链接地址中明确的指出调用的参数是什么，而是会在http协议的报文中携带参数。将调用参数放在报文里会更加的安全，避免别人看到敏感的信息，比如用户名和密码。 获取网络数据的通用方法现在的应用几乎都离不开网络访问，Android SDK已经继承了对网络访问的全面支持。 使用HttpURLConnection，就能获取该链接下的内容， 通过访问地址创建URL， 1234567URL url = null;try &#123; url = new URL(&quot;http://booktest.anddle.com/api/query_weather&quot;); &#125; catch (MalformedURLException e) &#123; e.printStackTrace();&#125; 利用HttpURLConnection的openConnection()连接网络， 123456try &#123; HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); &#125; catch (IOException e) &#123; e.printStackTrace();&#125; 通过打开的连接获取流接口，并通过流接口读取数据， 123456789101112InputStream in = null;try &#123; in = new BufferedInputStream(urlConnection.getInputStream()); byte[] buffer = new byte[2048]; int readBytes = 0; StringBuilder stringBuilder = new StringBuilder(); while((readBytes = in.read(buffer)) &gt; 0)&#123; stringBuilder.append(new String(buffer, 0, readBytes)); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 关闭连接， 1urlConnection.disconnect(); 获取天气预报数据使用HttpURLConnection获取天气数据的过程是个需要在工作线程中进行的工作。因此，需要将它放到UpdateTask的doInBackground()方法当中。 将原有的写死的假数据移除，代替以真实的网络获取数据。 123456789101112131415161718192021222324252627282930313233343536@Overrideprotected Void doInBackground(Void... params) &#123; Log.d(\"TEST\",\"UpdateTask doInBackground - ThreadId = \" + Thread.currentThread().getId()); try &#123; URL url = new URL(\"http://booktest.anddle.com/api/query_weather\"); HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); InputStream in = new BufferedInputStream(urlConnection.getInputStream()); byte[] buffer = new byte[2048]; int readBytes = 0; StringBuilder stringBuilder = new StringBuilder(); while((readBytes = in.read(buffer)) &gt; 0)&#123; stringBuilder.append(new String(buffer, 0, readBytes)); &#125; urlConnection.disconnect(); String weatherRes = stringBuilder.toString(); ...... &#125; catch (JSONException e) &#123; e.printStackTrace(); Log.d(\"TEST\",\"fail to parse JSON content\"); &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; 增加权限安卓系统对每个应用程序都有严格的权限控制，如果程序要访问网络，必须明确的告诉用户。 这是对用户利益的保护，谁也不愿意一个程序在自己不知情的情况下做一些可能会侵犯自己隐私的事情吧。 如果不添加，那么程序在运行的时候会报这样的错误， 添加网络访问权限很简单，打开项目工程的AndroidManifest.xml文件，在application标签之前，添加上&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;， 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.anddle.weatherapp\"&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt; &lt;application ......&gt; ...... &lt;/application&gt;&lt;/manifest&gt; 这时运行程序就不会有问题了。 至此，天气预报应用的功能就全部实现了。 其他访问网络数据的方式在使用AsyncTask的过程中，我们可以体会到它的好处：将耗时不确定的操作与界面刷新整合在了一起，我们开发者不需要使用原始的Thread，不需要去考虑工作线程与主线程如何配合工作这个细节了。 那么也许Android SDK还可以提供一个针对网络访问的异步解决方案： 网络访问在工作线程中（不像AsyncTask提供的是一个通用的耗时操作）； 界面刷新在主线程中； 针对上面的需求，出现了一些不错的第三方解决方案，例如OKHttp volley等等。它们就像是一个个轮子，我们不需要重新开放这些功能了，直接拿过来用就可以了。 在这系列的文章中，我们暂时不适用第三方库做开发，先充分的认识下纯正的安卓开发。 天气API为了开发的方便、降低入门的难度，我自己写了一个简单的网络服务提供天气信息。但这并不是真实有效的信息，大家只能用来学习开发使用。 但是互联网上有很多第三方机构提供了真实可用的天气预报。例如心知天气。 它提供了很多天气信息相关的调用接口。 这些接口和我之前介绍的都很类似，例如查询当前天气的接口：https://api.thinkpage.cn/v3/weather/now.json?key=your_api_key&amp;location=beijing&amp;language=zh-Hans&amp;unit=c 返回的结果如下， 123456789101112131415161718192021222324252627&#123; \"results\": [&#123; \"location\": &#123; \"id\": \"C23NB62W20TF\", \"name\": \"西雅图\", \"country\": \"US\", \"timezone\": \"America/Los_Angeles\", \"timezone_offset\": \"-07:00\" &#125;, \"now\": &#123; \"text\": \"多云\", //天气现象文字 \"code\": \"4\", //天气现象代码 \"temperature\": \"14\", //温度，单位为c摄氏度或f华氏度 \"feels_like\": \"14\", //体感温度，单位为c摄氏度或f华氏度 \"pressure\": \"1018\", //气压，单位为mb百帕或in英寸 \"humidity\": \"76\", //相对湿度，0~100，单位为百分比 \"visibility\": \"16.09\", //能见度，单位为km公里或mi英里 \"wind_direction\": \"西北\", //风向文字 \"wind_direction_degree\": \"340\", //风向角度，范围0~360，0为正北，90为正东，180为正南，270为正西 \"wind_speed\": \"8.05\", //风速，单位为km/h公里每小时或mph英里每小时 \"wind_scale\": \"2\", //风力等级，请参考：http://baike.baidu.com/view/465076.htm \"clouds\": \"90\", //云量，范围0~100，天空被云覆盖的百分比 #目前不支持中国城市# \"dew_point\": \"-12\" //露点温度，请参考：http://baike.baidu.com/view/118348.htm #目前不支持中国城市# &#125;, \"last_update\": \"2015-09-25T22:45:00-07:00\" //数据更新时间（该城市的本地时间） &#125;]&#125; 关于这一段更为详细的描述请看它的官方文档，对每个参数和返回值都有解释。 这是一个需要注册或者付费的服务，也是我没有选择使用它来做例子的原因。 如果大家学习了本文很有兴趣，可以将查询天气信息的接口改成这里真实的服务地址，做成一个实用的应用。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"12 数据的异步更新","slug":"4_开发/12_数据的异步更新","date":"2017-02-06T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/12_数据的异步更新/","link":"","permalink":"http://booktest.anddle.com/4_开发/12_数据的异步更新/","excerpt":"","text":"界面的异步更新前面我们获取的数据是假数据，只要需要，马上就能得到。但是实际的情况下，我们将从网络获取数据。 从网络获取数据有很大的不确定性，主要体现在消耗的时间不确定。假如当时的网络情况非常很好，瞬间就能得到期望的数据，就像是使用在代码中写死的假数据一样；假如网络情况很糟糕，发起数据请求后几十秒钟才能获得结果。 由此可见，通过网络获取数据，花费的时间是说不清楚的。 安卓应用只有一个主线程－各个组件都是在这个线程中运行。作为组件的之一的Activity就是在这个线程中更新应用界面的，例如，用户点击界面上的一个按钮，按钮得到响应，整个过程就是在这个主线程里。所以这个主线程绝对不可以做耗时的操作。假如在按钮中做了耗时的操作，那么当它进行耗时操作的时候，你去点击界面上的其它按钮是不会有反应的，就好像程序冻在了那里。 比如说，我们看到的这个onCreate()函数，就是在主线程中执行的。如果在这个主线程中进行网络访问，等着在不确定的时间内收到结果，那么主线程在等待的过程中啥也不能做，整个程序就好像是僵死在那里。 我们的代码一旦连续占用这个线程超过一定的时间，系统甚至就会弹出“程序无响应的”提示，这个提示叫做ANR-Applicatin No Response。 所以每当需要进行与界面操作不相关的耗时操作时，比如访问网络获取数据，就需要开辟另一个线程-叫做工作线程。在工作线程中进行耗时工作，然后再将处理的结果告诉主线程，让主线程进行界面更新的工作。 这就好比你在正在做一件事情A，突然另一件事情B来打扰你，你不得不停下手头的工作来完成，做完了才能继续之前的工作；这时如果有另外一个人（另一个线程）来帮助你，把事情B全部包揽了，那你就不用分心了。当另一个人把事情B做完后，告诉你一声就可以了。 因此，在从网络获取真实的数据之前，我们要首先解决在工作线程中如何异步刷新界面的问题。 工作线程启动一个新的线程，分担耗时工作的方法是一种异步操作：我让你帮我做一件事情，布置任务后，我就去做其他的事情了，等你做完了再告诉我结果； 与它对应的是同步操作：我让你帮我做一件事情，布置任务后，我啥也不做，就等着你做完了告诉我结果； 获取网络信息是个异步操作，启动一个新线程－工作线程thread－查询网络数据，查询完成后，工作线程再将结果通知到主线程，让主线程将查询到结果的结果显示到界面上。界面的更新一定要在主线程中进行，不能在别的线程修改，否则系统后提示运行错误，这一点相当重要。因此我们一定要将查询的结果发送给主线程，让主线程处理界面的更新。 安卓系统提供的异步操作方案有： 创建工作线程thread和Handler，利用Handler在工作线程和主线程之间传递数据； 使用AsyncTask帮助类， 考虑到2个因素， 耗时的工作要开辟一个工作线程，在其中进行工作； 耗时工作的结果要返回给主线程，由主线程更新界面； Android SDK提供了AsyncTask实现耗时操作的使用场景。 虽然将AsyncTask看成是一个单独的方案，但实际上它也是通过方案1实现的，只不过对于使用者来讲更加方便而已。 它们的本质都是创建一个Thread对象，然后让它运行起来。 12Thread thread = new Thread();thread.start(); 这里我们选择方案2。因为， 使用场景简单，只是单个任务的异步操作，没有多个线程之间的数据同步考虑； 使用方便，不用考虑太多的新线程创建的细节； AsyncTask的用法AsyncTask需要被继承成为一个新的子类来使用，在被继承时，要指定三种参数的类型－Param Progress Result，还需要实现doInBackground(Param...)函数，此外通常还要实现onProgressUpdate(Progress...) onPostExecute(Result) 两个回调函数。 12345678910111213141516171819202122class MyTask extends AsyncTask&lt;Param, Progress, Result&gt; &#123; @Override protected Result doInBackground(Param... params) &#123; return result; &#125; @Override protected void onProgressUpdate(Progress... progresses) &#123; &#125; @Override protected void onPostExecute(Result result) &#123; &#125; @Override protected void onCancelled() &#123; &#125;&#125; doInBackground(Param... params)函数：传入参数的Param类型就是AsyncTask&lt;Param, Progress, Result&gt;中指定的Param类型。它运行在新创建的工作线程当中。 使用MyTask时，要在主线程中使用excute()方法传入不定长参数，让Task运行起来， 12MyTask task = new MyTask();task.excute(param0, param1, ..., paramN); 不定长参数会以数组的形式传递到doInBackground()函数当中， 123456789@Overrideprotected Result doInBackground(Param... params) &#123; Param param0 = params[0]; Param param1 = params[1]; ...... Param paramN = params[N]; return result;&#125; onProgressUpdate(Progress... progresses)函数：传入参数的Progress类型就是AsyncTask&lt;Param, Progress, Result&gt;中指定的Progress类型。 在doInBackground()中执行的是一个很耗时的工作，有时需要向主线程报告当前的运行状况，这就要使用到publishProgress()函数，publishProgress()也是使用的不定长参数， 1234567@Overrideprotected Result doInBackground(Param... params) &#123; ...... publishProgress(progress1, progress2, ..., progressN) return result;&#125; 不定长参数会以数组的形式传递到onProgressUpdate()函数当中， 12345678@Overrideprotected void onProgressUpdate(Progress... progresses) &#123; Progress progress0 = progresses[0]; Progress progress1 = progresses[1]; ...... Progress progressN = progresses[N]; &#125; onPostExecute(Result result)函数：传入参数的Result类型就是AsyncTask&lt;Param, Progress, Result&gt;中指定的Result类型。 doInBackground()函数返回的类型也是Result 123456@Overrideprotected Result doInBackground(Param... params) &#123; ...... return result;&#125; 返回的结果作为参数传递给onPostExecute()函数， 1234@Overrideprotected void onPostExecute(Result result) &#123;&#125; onCancel()函数会在调用者取消AsyncTask的工作的时候被触发。 要取消AsyncTask的工作，首先要在主线程中调用cancel()方法， 1task.cancel(true); 因为在doInBackground()中执行的是一个很耗时的工作，需要时不时的检查自己是否被取消执行了， 123456789101112@Overrideprotected Result doInBackground(Param... params) &#123; ...... if(isCancelled()) &#123; ...... return result; &#125; ...... return result;&#125; 最后，onCancelled()函数会被触发，这个函数会在主线程中被执行， 1234@Overrideprotected void onCancelled() &#123;&#125; 综合上面的分析，自定义一个AsyncTask的方法如下， 12345678910111213141516171819202122232425262728293031323334353637class MyTask extends AsyncTask&lt;Param, Progress, Result&gt; &#123; @Override protected Result doInBackground(Param... params) &#123; Param param0 = params[0]; Param param1 = params[1]; ...... Param paramN = params[N]; while(!isCancelled()) &#123; ...... publishProgress(progress1, progress2, ..., progressN); &#125; return result; &#125; @Override protected void onProgressUpdate(Progress... progresses) &#123; Progress progress0 = progresses[0]; Progress progress1 = progresses[1]; ...... Progress progressN = progresses[N]; ...... &#125; @Override protected void onPostExecute(Result result) &#123; &#125; @Override protected void onCancelled() &#123; &#125;&#125; 使用一个AsyncTask的方法如下， 1234MyTask task = new MyTask();task.excute(param0, param1, ..., paramN);...... task.cancel(true); AsyncTask中解析天气数据根据我们的需要，自己定义个AsyncTask－UpdateTask， 不需要为新创建的线程传入参数；所以Param设置成Object； 获取网络数据以及解析数据的是一个耗时不确定的过程。为了减小我们开发的难度，可以假设在完成整个过程之前，不需要通知主线程当前查询的状态；所以Progress设置成Void； 解析出来的结果有3类，天气详情信息，天气预报信息和天气更多信息。 但是AsyncTask发送给主线程的内容只能包含在一个Result参数当中。 为此可以有两种办法， 在定义一个结构体，把这3类数据放里面，让它们整体作为一个Result； 把这3类数据作为UpdateTask的成员变量直接使用，作为结果的保存对象； 同样为了简化问题，我决定使用第2个方法。因此Result设置成Void；再分别设置3类数据的成员变量 1234567891011121314151617181920212223242526private class UpdateTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; private String mLocation; private String mTemperature; private String mTemperatureRange; private int mWeatherCode; private List&lt;ForcastInfo&gt; mForcastList; private List&lt;WeatherMoreInfo&gt; mWeatherMoreInfoList; @Override protected Void doInBackground(Void... params) &#123; return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; &#125; @Override protected void onCancelled() &#123; &#125; &#125; 将获取网络数据和解析数据的工作放到doInBackground()中进行，这是在一个新创建的工作线程中执行的；并且将解析的结果保存到UpdateTask的成员变量当中， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Overrideprotected Void doInBackground(Void... params) &#123; try &#123; Log.d(\"TEST\",\"start to parse JSON content\"); JSONObject weatherResult = new JSONObject(FAKE_DATA); int errorCode = weatherResult.getInt(\"error_code\"); Log.d(\"TEST\", \"error_code = \" + errorCode); if(errorCode == 0) &#123; JSONObject data = weatherResult.getJSONObject(\"data\"); mLocation = data.getString(\"location\"); mTemperature = data.getString(\"temperature\"); mTemperatureRange = data.getString(\"temperature_range\"); mWeatherCode = data.getInt(\"weather_code\"); Log.d(\"TEST\",\"weather detail info:\"+ \" location = \" + mLocation + \" temperature = \" + mTemperature + \" temperatureRange = \" + mTemperatureRange + \" weatherCode = \" + mWeatherCode); JSONArray forcast = data.getJSONArray(\"forcast\"); mForcastList = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; forcast.length(); i++) &#123; JSONObject forcastItem = forcast.getJSONObject(i); String date = forcastItem.getString(\"date\"); String forcastTemperatureRange = forcastItem.getString(\"temperature_range\"); int forcastWeatherCode = forcastItem.getInt(\"weather_code\"); Log.d(\"TEST\",\"weather forcast info:\"+ \" date = \" + date + \" forcastTemperatureRange = \" + forcastTemperatureRange + \" forcastWeatherCode = \" + forcastWeatherCode); ForcastInfo forcastInfo = new ForcastInfo(date, forcastTemperatureRange, forcastWeatherCode); mForcastList.add(forcastInfo); &#125; String windDirection = data.getString(\"wind_direction\"); String windLevel = data.getString(\"wind_level\"); String humidityLevel = data.getString(\"humidity_level\"); String airQuality = data.getString(\"air_quality\"); String sportLevel = data.getString(\"sport_level\"); String ultravioletRay = data.getString(\"ultraviolet_ray\"); Log.d(\"TEST\",\"more weather info:\"+ \" windDirection = \" + windDirection + \" windLevel = \" + windLevel + \" humidityLevel = \" + humidityLevel + \" airQuality = \" + airQuality + \" sportLevel = \" + sportLevel + \" ultravioletRay = \" + ultravioletRay ); mWeatherMoreInfoList = new ArrayList&lt;&gt;(); WeatherMoreInfo info1 = new WeatherMoreInfo(\"wind_direction\", windDirection); WeatherMoreInfo info2 = new WeatherMoreInfo(\"wind_level\", windLevel); WeatherMoreInfo info3 = new WeatherMoreInfo(\"humidity_level\", humidityLevel); WeatherMoreInfo info4 = new WeatherMoreInfo(\"air_quality\", airQuality); WeatherMoreInfo info5 = new WeatherMoreInfo(\"sport_level\", sportLevel); WeatherMoreInfo info6 = new WeatherMoreInfo(\"ultraviolet_ray\", ultravioletRay); mWeatherMoreInfoList.add(info1); mWeatherMoreInfoList.add(info2); mWeatherMoreInfoList.add(info3); mWeatherMoreInfoList.add(info4); mWeatherMoreInfoList.add(info5); mWeatherMoreInfoList.add(info6); Log.d(\"TEST\",\"finish to parse JSON content\"); &#125; else &#123; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); Log.d(\"TEST\",\"fail to parse JSON content\"); &#125; return null;&#125; 将解析完成，刷新界面的工作放到onPostExecute()中进行，这是运行在主线程上的，所以可以用来更新界面， 1234567@Overrideprotected void onPostExecute(Void aVoid) &#123; updateWeatherDetail(mLocation, mTemperature, mTemperatureRange, mWeatherCode); updateWeatherForcast(mForcastList); updateWeatherMoreInfo(mWeatherMoreInfoList);&#125; AsyncTask的使用在天气应用的MainActivity创建的时候，我们就启动UpdateTask，开始更新界面的工作。 1234567891011private AsyncTask mUpdateTask;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ...... mUpdateTask = new UpdateTask(); mUpdateTask.execute();&#125; 在MainActivity退出的时候，判断mUpdateTask是否还在运行，如果还在运行，就让它停止， 12345678910@Overrideprotected void onDestroy() &#123; super.onDestroy(); if((mUpdateTask != null) &amp;&amp; (mUpdateTask.getStatus() == AsyncTask.Status.RUNNING)) &#123; mUpdateTask.cancel(true); &#125; mUpdateTask = null;&#125; onCreate()与onDestroy()是Activity生命周期的一部分，当一个Activity被创建的时候会调用到onCreate()，当Activity被退出销毁的时候会调用到onDestroy()。所以在这两个地方使用UpdateTask是一个合适的选择。 验证主线程与工作线程代码写完了，我们来验证一下AsyncTask是否如我之前介绍的那样，将不同的工作自动的放到了主线程与工作线程之中进行。 系统运行时，会未每一个程序分配一个进程ID-PID，每个进程可以有多个线程，而每个线程又会根据线程的数量给它们分配对于的线程ID-TID。 Android SDK提供了一个叫做Thread.currentThread()的函数，能获取执行当前函数所用线程TID值。 使用Log.d()将这两个信息打印出来看看， 123456789101112131415161718private class UpdateTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; @Override protected Void doInBackground(Void... params) &#123; Log.d(\"TEST\",\"UpdateTask doInBackground - ThreadId = \" + Thread.currentThread().getId()); ...... &#125; @Override protected void onPostExecute(Void aVoid) &#123; Log.d(\"TEST\",\"UpdateTask onPostExecute - ThreadId = \" + Thread.currentThread().getId()); ...... &#125; &#125; 从log中可以看到，工作线程的线程id是1008；而主线程的线程id是1。 这和我们之前的介绍一样。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"11 界面的更新","slug":"4_开发/11_界面的更新","date":"2017-02-05T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/11_界面的更新/","link":"","permalink":"http://booktest.anddle.com/4_开发/11_界面的更新/","excerpt":"","text":"界面的更新解析出天气预报的各种数据之后，就需要将它们反映到界面上了。 更新的原理很简单，通过findViewById()获取要更新的各种控件，然后将要更新的数据设置给这些控件就可以了。例如， 12345//获取控件TextView currentTemperatureView = (TextView) findViewById(R.id.current_temperature);//使用控件currentTemperatureView.setText(temperature); 天气详情界面 添加一个更新天气详情界面的函数，把这个界面更新的操作放在一起，便于维护； 传人位置、温度、温度范围、天气状态等几个更新界面需要用到的信息， 12345678public class ScrollingActivity extends AppCompatActivity &#123; ...... private void updateWeatherDetail(String location, String temperature, String temperatureRange, int weatherCode) &#123; &#125;&#125; 通过findViewById()找到需要更新的控件-天气图标、当前温度、温度范围， 12345678private void updateWeatherDetail(String location, String temperature, String temperatureRange, int weatherCode) &#123; TextView currentTemperatureView = (TextView) findViewById(R.id.current_temperature); TextView temperatureRangeView = (TextView) findViewById(R.id.temperature_range); ImageView weatherIcon = (ImageView) findViewById(R.id.weather_icon); TextView weatherLocation = (TextView) findViewById(R.id.weather_location); &#125; 将当前温度、温度范围和位置设置到界面上， 1234567891011private void updateWeatherDetail(String location, String temperature, String temperatureRange, int weatherCode) &#123; TextView currentTemperatureView = (TextView) findViewById(R.id.current_temperature); TextView temperatureRangeView = (TextView) findViewById(R.id.temperature_range); ImageView weatherIcon = (ImageView) findViewById(R.id.weather_icon); TextView weatherLocation = (TextView) findViewById(R.id.weather_location); currentTemperatureView.setText(temperature); temperatureRangeView.setText(temperatureRange); weatherLocation.setText(location);&#125; 这里TextView的setText()方法，就是设置控件显示内容的，它与xml布局文件中的android:text属性的功能一样。 根据协议约定的含义，将weather code代码转换成对应的图标，并设置给界面， 1234567891011121314151617181920212223242526272829303132private void updateWeatherDetail(String location, String temperature, String temperatureRange, int weatherCode) &#123; ...... int iconId = R.mipmap.ic_sunny_cloudy_l; switch (weatherCode) &#123; case 0: iconId = R.mipmap.ic_sunny_l; break; case 1: iconId = R.mipmap.ic_rainy_l; break; case 2: iconId = R.mipmap.ic_cloudy_l; break; case 3: iconId = R.mipmap.ic_fog_l; break; case 4: iconId = R.mipmap.ic_snow_l; break; case 5: iconId = R.mipmap.ic_sunny_cloudy_l; break; &#125; weatherIcon.setImageResource(iconId);&#125; 这里ImageView的setImageResource()方法，就是设置控件显示图片的，它与xml布局文件中的android:src属性的功能一样。 当解析出JSON数据以后，就可以使用updateWeatherDetail()来更新界面， 12345678910111213if(errorCode == 0) &#123; JSONObject data = weatherResult.getJSONObject(\"data\"); String location = data.getString(\"location\"); String temperature = data.getString(\"temperature\"); String temperatureRange = data.getString(\"temperature_range\"); int weatherCode = data.getInt(\"weather_code\"); ...... //更新数据 updateWeatherDetail(location, temperature, temperatureRange, weatherCode);&#125; 天气预报界面每个天气预报由3个信息组成：日期、温度范围、天气状态。其中天气状态决定了需要显示的图标。 新建一个java源文件-ForcastInfo.java，创建一个新类-ForcastInfo，使用3个变量保存天气预报项中的数据。 123456public class ForcastInfo &#123; public String date; public String temperatureRage; public int iconResId;&#125; 用iconResId保存天气状态对应的图标资源id。 因为iconResId保存的是天气状态对应的图标资源id，所以给iconResId赋值的时候得转化一番，因此我想到了给ForcastInfo设计一个构造函数， 123456789101112131415161718192021222324252627282930313233public class ForcastInfo &#123; ...... public ForcastInfo(String date, String temperatureRage, int weatherCode) &#123; this.date = date; this.temperatureRage = temperatureRage; this.iconResId = R.mipmap.ic_sunny_cloudy_s; switch (weatherCode) &#123; case 0: this.iconResId = R.mipmap.ic_sunny_s; case 1: this.iconResId = R.mipmap.ic_rainy_s; case 2: this.iconResId = R.mipmap.ic_cloudy_s; case 3: this.iconResId = R.mipmap.ic_fog_s; case 4: this.iconResId = R.mipmap.ic_snow_s; case 5: this.iconResId = R.mipmap.ic_sunny_cloudy_s; &#125; &#125;&#125; 构造函数中，将3个数据转换成了显示使用的数据。 添加一个更新天气预报区域的函数，把界面更新的操作放在一起，便于维护；传人ForcastInfo的列表，作为更新界面需要用到的信息， 12345678public class ScrollingActivity extends AppCompatActivity &#123; ...... private void updateWeatherForcast(List&lt;ForcastInfo&gt; list) &#123; &#125;&#125; 需要获取天气预报区域中，5个完全一样的布局，逐个更新这5个一样的布局， 12345678910111213141516171819202122232425262728293031public class ScrollingActivity extends AppCompatActivity &#123; ...... private void updateWeatherForcast(List&lt;ForcastInfo&gt; list) &#123; LinearLayout forcastItem1 = (LinearLayout) findViewById(R.id.forcast_item1); LinearLayout forcastItem2 = (LinearLayout) findViewById(R.id.forcast_item2); LinearLayout forcastItem3 = (LinearLayout) findViewById(R.id.forcast_item3); LinearLayout forcastItem4 = (LinearLayout) findViewById(R.id.forcast_item4); LinearLayout forcastItem5 = (LinearLayout) findViewById(R.id.forcast_item5); updateWeatherForcastItem(forcastItem1, list.get(0)); updateWeatherForcastItem(forcastItem2, list.get(1)); updateWeatherForcastItem(forcastItem3, list.get(2)); updateWeatherForcastItem(forcastItem4, list.get(3)); updateWeatherForcastItem(forcastItem5, list.get(4)); &#125; private void updateWeatherForcastItem(LinearLayout layout, ForcastInfo info) &#123; TextView date = (TextView) layout.findViewById(R.id.forcast_date); ImageView icon = (ImageView) layout.findViewById(R.id.forcast_icon); TextView temperatureRage = (TextView) layout.findViewById(R.id.forcast_temperature); date.setText(info.date); icon.setImageResource(info.iconResId); temperatureRage.setText(info.temperatureRage); &#125;&#125; 这里看似代码有很多雷同的地方，其实是可以通过循环来实现的（获取天气预报区域，然后遍历它的所有子布局）。不过这里只是为了介绍更新的方法，就不去那样写了。 当解析出JSON数据以后，将它封装成ForcastInfo对象，然后就可以使用updateWeatherForcast()来更新界面了， 123456789101112131415161718192021222324if(errorCode == 0) &#123; ...... JSONArray forcast = data.getJSONArray(\"forcast\"); //创建列表，准备保存数据 List&lt;ForcastInfo&gt; forcastInfoList = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; forcast.length(); i++) &#123; JSONObject forcastItem = forcast.getJSONObject(i); String date = forcastItem.getString(\"date\"); String forcastTemperatureRange = forcastItem.getString(\"temperature_range\"); int forcastWeatherCode = forcastItem.getInt(\"weather_code\"); ...... ForcastInfo forcastInfo = new ForcastInfo(date, forcastTemperatureRange, forcastWeatherCode); forcastInfoList.add(forcastInfo); &#125; //更新数据 updateWeatherForcast(forcastInfoList); ......&#125; 更多天气信息界面每条更多信息都由3个信息组成：图标、描述、取值。其中描述与图标是一一对应的关系，它们都是根据JSON字段的名称来确定的， JSON字段名称 描述 图片id wind_direction 风向 R.mipmap.ic_wind_direction wind_level 风力 R.mipmap.ic_wind_level humidity_level 湿度 R.mipmap.ic_humidity_level air_quality 空气质量 R.mipmap.ic_air_quality sport_level 运动 R.mipmap.ic_sport_level ultraviolet_ray 紫外线 R.mipmap.ic_ultraviolet_level 改造原有的WeatherMoreInfo类，让它也拥有一个构造函数，可以自动的根据JSON字段名称翻译描述文字和对应的图片， 1234567891011121314151617181920212223242526272829303132333435363738394041public class WeatherMoreInfo &#123; ...... public WeatherMoreInfo(String keyword, String value) &#123; this.value = value; switch (keyword) &#123; case \"wind_direction\": this.typeResId = R.mipmap.ic_wind_direction; this.description = \"风向\"; break; case \"wind_level\": this.typeResId = R.mipmap.ic_wind_level; this.description = \"风力\"; break; case \"humidity_level\": this.typeResId = R.mipmap.ic_humidity_level; this.description = \"湿度\"; break; case \"air_quality\": this.typeResId = R.mipmap.ic_air_quality; this.description = \"空气质量\"; break; case \"sport_level\": this.typeResId = R.mipmap.ic_sport_level; this.description = \"运动\"; break; case \"ultraviolet_ray\": this.typeResId = R.mipmap.ic_ultraviolet_level; this.description = \"紫外线\"; break; &#125; &#125;&#125; 添加更新更多天气信息列表的函数updateWeatherMoreInfo()， 12345678private void updateWeatherMoreInfo(List&lt;WeatherMoreInfo&gt; list) &#123; mWeatherMoreInfoList.clear(); mWeatherMoreInfoList.addAll(list); WeatherMoreInfoAdapter adapter = (WeatherMoreInfoAdapter) mWeatherMoreInfoListView.getAdapter(); adapter.notifyDataSetChanged();&#125; 这里面对Adapter中数据的修改要在主线程中进行，修改完成后，使用notifyDataSetChanged()刷新界面。 当解析出JSON数据以后，将它封装成WeatherMoreInfo对象，然后就可以使用updateWeatherMoreInfo()来更新界面了， 123456789101112131415161718192021222324252627282930if(errorCode == 0) &#123; ...... String windDirection = data.getString(\"wind_direction\"); String windLevel = data.getString(\"wind_level\"); String humidityLevel = data.getString(\"humidity_level\"); String airQuality = data.getString(\"air_quality\"); String sportLevel = data.getString(\"sport_level\"); String ultravioletRay = data.getString(\"ultraviolet_ray\"); //创建一个列表存储更多天气信息的数据 List&lt;WeatherMoreInfo&gt; weatherMoreInfoList = new ArrayList&lt;&gt;(); WeatherMoreInfo info1 = new WeatherMoreInfo(\"wind_direction\", windDirection); WeatherMoreInfo info2 = new WeatherMoreInfo(\"wind_level\", windLevel); WeatherMoreInfo info3 = new WeatherMoreInfo(\"humidity_level\", humidityLevel); WeatherMoreInfo info4 = new WeatherMoreInfo(\"air_quality\", airQuality); WeatherMoreInfo info5 = new WeatherMoreInfo(\"sport_level\", sportLevel); WeatherMoreInfo info6 = new WeatherMoreInfo(\"ultraviolet_ray\", ultravioletRay); weatherMoreInfoList.add(info1); weatherMoreInfoList.add(info2); weatherMoreInfoList.add(info3); weatherMoreInfoList.add(info4); weatherMoreInfoList.add(info5); weatherMoreInfoList.add(info6); ...... //更新数据 updateWeatherMoreInfo(weatherMoreInfoList); ......&#125; 其他有编码基础的高手们在看完前面的代码之后，一定发现了不少代码潜在的问题：我没有去考虑数据解析失败、联网失败的情况。一旦发生这样的情况，程序就会崩溃。 是的，你看的很仔细，很善于思考。这些缺陷我是故意留下的。这些缺陷用专业的叫法就是bug。我留下了这些伏笔，准备再后面的测试章节单独来进行处理。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"10 解析天气预报数据","slug":"4_开发/10_解析天气预报数据","date":"2017-02-04T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/10_解析天气预报数据/","link":"","permalink":"http://booktest.anddle.com/4_开发/10_解析天气预报数据/","excerpt":"","text":"解析天气预报数据界面布局完成以后，就需要设计代码来控制界面上各个元素的逻辑了。 从网络获取天气预报数据； 解析获取的数据； 根据解析的结果更新天气预报界面； 天气预报数据依赖于网络端的服务器，不是我们应用开发者自己能决定的。假如应用和网络服务器是两拨人同时在开发，极有可能出现应用端需要获取数据的时候，服务器端还没有准备好数据的情况。 这种情况怎么办呢？ 我们应用开发者可以自己构造一个假数据，模拟已经获取到真实数据的情形。当然，这样的假数据从格式到内容要尽量和网络端提供的真实数据一致。两者越是相同，后面使用真实数据时所作的修改就越是容易。 所以在实际的开发项目中，应用开发者和网络端开发者会拟定一个数据协议，应用开发者看这个协议就知道假数据如何构造了，而不用总是打断网络端开发者的工作。网络端开发者的开发也会严格按照这个协议来执行，不然将来的配合就是鸡同鸭讲。 这里我们先假设已经获取道了网络上的天气预报数据，看看如何来解析数据，并更新天气预报界面。 数据格式现在应用端（客户端）与网络端（服务器端）之间的数据交换，通常会使用两种格式的文本内容：XML与JSON。 比如通过网络获取一个班级学生的信息（假设包含学生的姓名、年龄、性别等3个内容）。 姓名 年龄 性别 赵一 15 男 钱二 14 女 孙三 16 女 李四 12 男 使用XML来传递信息，可能的内容就是： 1234567891011121314151617181920212223242526&lt;students&gt; &lt;student&gt; &lt;name&gt;赵一&lt;/name&gt; &lt;age&gt;15&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;钱二&lt;/name&gt; &lt;age&gt;14&lt;/age&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;孙三&lt;/name&gt; &lt;age&gt;16&lt;/age&gt; &lt;sex&gt;女&lt;/sex&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;12&lt;/age&gt; &lt;sex&gt;男&lt;/sex&gt; &lt;/student&gt;&lt;/students&gt; 每个节点&lt;&gt;代表一个数据。 使用JSON来传递信息，可能的内容就是： 12345678910111213141516171819202122232425&#123; \"students\": [ &#123; \"name\":\"赵一\", \"age\":\"15\", \"sex\":\"男\" &#125;, &#123; \"name\":\"钱二\", \"age\":\"14\", \"sex\":\"女\" &#125;, &#123; \"name\":\"孙三\", \"age\":\"16\", \"sex\":\"女\" &#125;, &#123; \"name\":\"李四\", \"age\":\"12\", \"sex\":\"男\" &#125; ]&#125; XML与JSON相比，JSON格式的数据占用的空间更小，表达方式更简洁一些。所以JSON似乎更受开发者的欢迎。 我们这里采用的就是JSON格式的数据。 JSON初步JSON格式的理解也很简单。 数据由名称和取值构成，例如&quot;name&quot;:&quot;李四&quot;， 它们由:分隔开，并且用&quot;括了起来（对于数值型的取值可以不用引号扩起来，但为了简化大家记忆的规则，都还是扩起来吧）； :后面可以跟[]，也可以跟{}；不同的括号，代表数据的不同类型； 123\"name\":\"李四\"\"age\":\"12\"\"sex\":\"男\" 使用{}，表现的是同一个事物的不同项， 12345&#123; \"name\":\"李四\" \"age\":\"12\" \"sex\":\"男\"&#125; 使用[]，表现的是同一类事物，内部会有多个平级的数据项； 123456789101112\"data\": [ &#123; \"item\":\"1\", &#125;, &#123; \"item\":\"2\", &#125;, &#123; \"item\":\"3\", &#125;] 天气数据根据之前的功能规划，我们确定了网络数据的格式，拿出一个实实在在的例子感受一下吧： 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; \"error_code\": \"0\", \"data\": &#123; \"location\": \"成都\", \"temperature\": \"23°\", \"temperature_range\": \"18℃~23℃\", \"weather_code\": \"5\", \"wind_direction\": \"东南\", \"wind_level\": \"1级\", \"humidity_level\": \"30%\", \"air_quality\": \"良\", \"sport_level\": \"适宜\", \"ultraviolet_ray\": \"弱\", \"forcast\": [ &#123; \"date\": \"明天\", \"temperature_range\": \"18℃~23℃\", \"weather_code\": \"0\" &#125;, &#123; \"date\": \"星期六\", \"temperature_range\": \"17℃~21℃\", \"weather_code\": \"1\" &#125;, &#123; \"date\": \"星期日\", \"temperature_range\": \"19℃~24℃\", \"weather_code\": \"3\" &#125;, &#123; \"date\": \"星期一\", \"temperature_range\": \"16℃~22℃\", \"weather_code\": \"4\" &#125;, &#123; \"date\": \"星期二\", \"temperature_range\": \"20℃~26℃\", \"weather_code\": \"2\" &#125; ] &#125;&#125; 可以看到整个数据分成了两个大的部分， error_code：网络端服务器返回的错误代码，假如服务器发现自身有问题，可以通过这个字段的数值告诉客户端。客户端收到返回值以后，首先要检查这个字段是否为0。对于非0值，我们就要警惕了，说明data字段的取值也许就是无效的了。 不过你也要记住，这个返回的JSON内容，都是应用开发者和网络开发者协商好的，你们也可以不设计error_code这个字段。但是目前大家已经形成了一个不成文的规定，都将这个字段作为JSON数据的标配。 data：携带我们真正关心的实际数据，所有天气相关的数据都放在这个字段当中。 接下来的分析，我们将集中于data字段。 天气详情数据天气详情数据需要使用到如下内容， 1234\"location\": \"成都\",\"temperature\": \"23°\",\"temperature_range\": \"18℃~23℃\",\"weather_code\": \"5\", 大部分数据的取值就是我们要显示到界面上的内容，这很简单。例如， 字段 取值 显示 location 成都 成都 temperature 23° 23° temperature_range 18℃~23℃ 18℃~23℃ weather_code字段，取值是数值，不同的数值，代表了不同的天气状态， 取值 天气状态 应用显示对应的图标 0 晴 R.mipmap.ic_sunny_l 1 雨 R.mipmap.ic_rainy_l 2 多云 R.mipmap.ic_cloudy_l 3 雾 R.mipmap.ic_fog_l 4 雪 R.mipmap.ic_snow_l 5 晴间多云 R.mipmap.ic_sunny_cloudy_l 天气预报数据天气预报数据包含5个子项， 123456789101112131415161718192021222324252627\"forcast\": [ &#123; \"date\": \"明天\", \"temperature_range\": \"18℃~23℃\", \"weather_code\": \"0\" &#125;, &#123; \"date\": \"星期六\", \"temperature_range\": \"17℃~21℃\", \"weather_code\": \"1\" &#125;, &#123; \"date\": \"星期日\", \"temperature_range\": \"19℃~24℃\", \"weather_code\": \"3\" &#125;, &#123; \"date\": \"星期一\", \"temperature_range\": \"16℃~22℃\", \"weather_code\": \"4\" &#125;, &#123; \"date\": \"星期二\", \"temperature_range\": \"20℃~26℃\", \"weather_code\": \"2\" &#125;] 大部分数据的取值就是我们要显示到界面上的内容，这很简单。例如， 字段 取值 显示 date 星期一 星期一 temperature_range 16℃~22℃ 16℃~22℃ weather_code字段，取值是数值，不同的数值，代表了不同的天气状态，对它的理解与天气预报数据中的weather_code一样，只是图标变小了， 取值 天气状态 应用显示对应的图标 0 晴 R.mipmap.ic_sunny_s 1 雨 R.mipmap.ic_rainy_s 2 多云 R.mipmap.ic_cloudy_s 3 雾 R.mipmap.ic_fog_s 4 雪 R.mipmap.ic_snow_s 5 晴间多云 R.mipmap.ic_sunny_cloudy_s 更多天气信息更多天气信息需要使用到如下内容， 123456\"wind_direction\": \"东南\",\"wind_level\": \"1级\",\"humidity_level\": \"30%\",\"air_quality\": \"良\",\"sport_level\": \"适宜\",\"ultraviolet_ray\": \"弱\" 大部分数据的取值就是我们要显示到界面上的内容，这很简单。例如， 字段 取值 显示 使用的图标 wind_direction 东南 东南 R.mipmap.ic_wind_direction wind_level 1级 1级 R.mipmap.ic_wind_level humidity_level 30% 30% R.mipmap.ic_humidity_level air_quality 良 良 R.mipmap.ic_air_quality sport_level 适宜 适宜 R.mipmap.ic_sport_level ultraviolet_ray 弱 弱 R.mipmap.ic_ultraviolet_level 解析JSON数据Android SDK给我们提供了非常好的JSON解析支持，我们不需要冲头去写一个解析器，直接拿过来用就好了。 添加JSON假数据， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MainActivity extends AppCompatActivity &#123; private final String FAKE_DATA= \"&#123;\\n\" + \" \\\"error_code\\\": \\\"0\\\",\\n\" + \" \\\"data\\\": &#123;\\n\" + \" \\\"location\\\": \\\"成都\\\",\\n\" + \" \\\"temperature\\\": \\\"23°\\\",\\n\" + \" \\\"temperature_range\\\": \\\"18℃~23℃\\\",\\n\" + \" \\\"weather_code\\\": \\\"5\\\",\\n\" + \" \\\"wind_direction\\\": \\\"东南\\\",\\n\" + \" \\\"wind_level\\\": \\\"1级\\\",\\n\" + \" \\\"humidity_level\\\": \\\"30%\\\",\\n\" + \" \\\"air_quality\\\": \\\"良\\\",\\n\" + \" \\\"sport_level\\\": \\\"适宜\\\",\\n\" + \" \\\"ultraviolet_ray\\\": \\\"弱\\\",\\n\" + \" \\\"forcast\\\": [\\n\" + \" &#123;\\n\" + \" \\\"date\\\": \\\"明天\\\",\\n\" + \" \\\"temperature_range\\\": \\\"18℃~23℃\\\",\\n\" + \" \\\"weather_code\\\": \\\"0\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"date\\\": \\\"星期六\\\",\\n\" + \" \\\"temperature_range\\\": \\\"17℃~21℃\\\",\\n\" + \" \\\"weather_code\\\": \\\"1\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"date\\\": \\\"星期日\\\",\\n\" + \" \\\"temperature_range\\\": \\\"19℃~24℃\\\",\\n\" + \" \\\"weather_code\\\": \\\"3\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"date\\\": \\\"星期一\\\",\\n\" + \" \\\"temperature_range\\\": \\\"16℃~22℃\\\",\\n\" + \" \\\"weather_code\\\": \\\"4\\\"\\n\" + \" &#125;,\\n\" + \" &#123;\\n\" + \" \\\"date\\\": \\\"星期二\\\",\\n\" + \" \\\"temperature_range\\\": \\\"20℃~26℃\\\",\\n\" + \" \\\"weather_code\\\": \\\"2\\\"\\n\" + \" &#125;\\n\" + \" ]\\n\" + \" &#125;\\n\" + \"&#125;\";......&#125; 删除之前为更多天气信息而创建的假数据，同时在onCreate()中创建一个JSON解析器， 12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ...... try &#123; JSONObject weatherResult = new JSONObject(FAKE_DATA); &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125;&#125; Android Studio会提示你处理try catch异常。假如程序运行时解析JSON字符串遇到了问题，会通过异常报错，让我们做进一步的处理。 解析error_code，判断数据是否可用， 123456789101112 try &#123; JSONObject weatherResult = new JSONObject(FAKE_DATA); int errorCode = weatherResult.getInt(\"error_code\"); if(errorCode == 0) &#123; &#125; else &#123; &#125;&#125; catch (JSONException e) &#123; e.printStackTrace();&#125; 这里使用了getInt(&quot;error_code&quot;)来获取error字段对应的值，并且把这个值解析成数值int类型。 解析天气详情数据 通过getJSONObject(&quot;data&quot;) 获取data字段的数据结构； 通过getString(xxx)、getInt(xxx)获取location temperature temperature_range weather_code等字段的具体内容； 1234567if(errorCode == 0) &#123; JSONObject data = weatherResult.getJSONObject(\"data\"); String location = data.getString(\"location\"); String temperature = data.getString(\"temperature\"); String temperatureRange = data.getString(\"temperature_range\"); int weatherCode = data.getInt(\"weather_code\");&#125; 解析天气预报数据 通过getJSONArray(&quot;forcast&quot;)获取forcast字段下所有的天气预报子项，一共有5个子项； 通过getString(xxx)和getInt(xxx)，获取date temperature_range weather_code等字段的内容； 1234567891011if(errorCode == 0) &#123; ...... JSONArray forcast = data.getJSONArray(\"forcast\"); for(int i = 0; i &lt; forcast.length(); i++) &#123; JSONObject forcastItem = forcast.getJSONObject(i); String date = forcastItem.getString(\"date\"); String forcastTemperatureRange = forcastItem.getString(\"temperature_range\"); int forcastWeatherCode = forcastItem.getInt(\"weather_code\"); &#125;&#125; 解析更多天气数据通过getString(xxx)获取wind_direction wind_level humidity_level air_quality sport_level ultraviolet_ray等字段的具体内容； 12345678910if(errorCode == 0) &#123; ...... String windDirection = data.getString(\"wind_direction\"); String windLevel = data.getString(\"wind_level\"); String humidityLevel = data.getString(\"humidity_level\"); String airQuality = data.getString(\"air_quality\"); String sportLevel = data.getString(\"sport_level\"); String ultravioletRay = data.getString(\"ultraviolet_ray\");&#125; 完整的代码如下， 12345678910111213141516171819202122232425262728293031323334353637@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ...... try &#123; JSONObject weatherResult = new JSONObject(FAKE_DATA); int errorCode = weatherResult.getInt(\"error_code\"); if(errorCode == 0) &#123; JSONObject data = weatherResult.getJSONObject(\"data\"); String location = data.getString(\"location\"); String temperature = data.getString(\"temperature\"); String temperatureRange = data.getString(\"temperature_range\"); int weatherCode = data.getInt(\"weather_code\"); JSONArray forcast = data.getJSONArray(\"forcast\"); for(int i = 0; i &lt; forcast.length(); i++) &#123; JSONObject forcastItem = forcast.getJSONObject(i); String date = forcastItem.getString(\"date\"); String forcastTemperatureRange = forcastItem.getString(\"temperature_range\"); int forcastWeatherCode = forcastItem.getInt(\"weather_code\"); &#125; String windDirection = data.getString(\"wind_direction\"); String windLevel = data.getString(\"wind_level\"); String humidityLevel = data.getString(\"humidity_level\"); String airQuality = data.getString(\"air_quality\"); String sportLevel = data.getString(\"sport_level\"); String ultravioletRay = data.getString(\"ultraviolet_ray\"); &#125; else &#123; &#125; &#125; catch (JSONException e) &#123; e.printStackTrace(); &#125;&#125; 关于调试解析的数据需要更新到界面上。但是在解析的过程中，我们希望能尽早看到解析的结果是否正确。 Android Studio为我们提供了两种调试代码、看到代码运行到中间状态的方法：断点调试和Log调试。 断点调试断点调试让程序在运行到某一个状态的时候，冻结应用运行的状态，仿佛时间停止了一般。然后让我们有时间逐一观察此时程序的各个参数是否符合我们的预期。 这种调试方法适用于对时间不敏感的程序。也就是说被调试的程序线程不需要依赖别的线程，即使暂时停止工作也不会影响别的工作线程或者受别的工作线程影响。 在希望代码暂停运行的地方打断点——在代码前点击一下，出现一个红色的圆点，如果想取消，再点击一次即可。 用debug run的方式(ctrl+D)部署程序。当程序运行到设置了端点的位置时，程序将停止下来，切换到Debug窗口。这时，我们就可以观察各个参数了。 例如下图右半区域就列出了停止时，各个变量的值；左边区域展示了当时函数到调用栈（谁调用的这个函数）情况。我们可以逐一分析，详细观察，看这些值是否符合我们的预期。 使用菜单栏中的Run -&gt; Step Over(或者快捷键F8)，能让程序往下执行一步。多按几次，就会依次往下执行几次。 这里可以看到我们解析的天气预报数据都没有问题。 端点调试有很多的快捷按键，都是值得我们记住的，可以大大加快我们的开发效率。 Log调试对于那些和时间相关的程序（不能让程序暂停，等你慢慢观察），我们就不能使用静态的设置断点的调试方法了，得采用动态调试，添加log的方式。 Log的中文名字叫做日志，在编程界表示程序运行过程中打印出的信息。根据log我们就知道现在程序运行到什么地方了，log还可以携带程序中某些变量的信息输出，让我们更精准的知道程序当前运行的状态。 代码中添加Log在代码中添加一段函数，就能通过特别的工具输出这些log。我们在创建工程的时候就用过了， 在Android代码中添加log的方式如下： 123456@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"TEST\", \"Weather app launched\");&#125; 这里面使用了Android提供的Log库，Log.d代表信息属于Debug类型。 我们给解析出的天气预报数据，都一一加上Log信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556try &#123; Log.d(\"TEST\",\"start to parse JSON content\"); JSONObject weatherResult = new JSONObject(FAKE_DATA); int errorCode = weatherResult.getInt(\"error_code\"); Log.d(\"TEST\", \"error_code = \" + errorCode); if(errorCode == 0) &#123; JSONObject data = weatherResult.getJSONObject(\"data\"); String location = data.getString(\"location\"); String temperature = data.getString(\"temperature\"); String temperatureRange = data.getString(\"temperature_range\"); int weatherCode = data.getInt(\"weather_code\"); Log.d(\"TEST\",\"weather detail info: \"+ \"location=\" + location + \"temperature=\" + temperature + \"temperatureRange=\" + temperatureRange + \"weatherCode=\" + weatherCode); JSONArray forcast = data.getJSONArray(\"forcast\"); for(int i = 0; i &lt; forcast.length(); i++) &#123; JSONObject forcastItem = forcast.getJSONObject(i); String date = forcastItem.getString(\"date\"); String forcastTemperatureRange = forcastItem.getString(\"temperature_range\"); int forcastWeatherCode = forcastItem.getInt(\"weather_code\"); Log.d(\"TEST\",\"weather forcast info: \"+ \"date=\" + date + \"forcastTemperatureRange=\" + forcastTemperatureRange + \"forcastWeatherCode=\" + forcastWeatherCode); &#125; String windDirection = data.getString(\"wind_direction\"); String windLevel = data.getString(\"wind_level\"); String humidityLevel = data.getString(\"humidity_level\"); String airQuality = data.getString(\"air_quality\"); String sportLevel = data.getString(\"sport_level\"); String ultravioletRay = data.getString(\"ultraviolet_ray\"); Log.d(\"TEST\",\"more weather info: \"+ \"windDirection=\" + windDirection + \"windLevel=\" + windLevel + \"humidityLevel=\" + humidityLevel + \"airQuality=\" + airQuality + \"sportLevel=\" + sportLevel + \"ultravioletRay=\" + ultravioletRay ); Log.d(\"TEST\",\"finish to parse JSON content\"); &#125; else &#123; &#125;&#125; catch (JSONException e) &#123; e.printStackTrace(); Log.d(\"TEST\",\"fail to parse JSON content\");&#125; Log的查看添加了log信息后，将程序通过debug app部署到设备上，就能在Android Monitor工具的logcat窗口中看到对应的信息了。 可以看出，我们对JSON的解析完全正确。 输出的调试信息，单条如下： 02-10 13:49:29.608 7948-7948/com.anddle.weatherapp D/TEST: error_code = 0 是不是可以猜出它所代表的含义呢？ Android应用开发的Log库提供了几种不同等级的log：Verbose Debug Info Warning Error，我们可以根据自己log的需要加不同等级的log，使用的形式为： 12345Log.v(“TAG”,”content is verbose”);Log.d(“TAG”,”content is debug”);Log.i(“TAG”,”content is info”);Log.w(“TAG”,”content is waring”);Log.e(“TAG”,”content is error”);","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"9 天气更多信息的布局","slug":"4_开发/9_天气更多信息的布局","date":"2017-02-03T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/9_天气更多信息的布局/","link":"","permalink":"http://booktest.anddle.com/4_开发/9_天气更多信息的布局/","excerpt":"","text":"天气更多信息的布局天气相关信息是通过列表方式呈现的。Android SDK提供的ListView控件就能实现这样功能。 ListView需要和Adapter配合使用，ListView负责内容的显示，Adapter负责为ListView提供要展示的数据。 要实现我们希望的展示效果，需要开发者自定义一个Adapter。那我们先把问题简化一下，看看ListView是怎么使用的。 ListView的基本方法先在我们的工程项目中，使用ListView展示点简单的内容，大家熟悉熟悉使用ListView的套路， 在activity_main.xml布局文件中，给ListView布局增加一个id叫做weather_more_info_list(在现有的代码中，我们之前已经增加过了)； 123456&lt;ListView android:id=\"@+id/weather_more_info_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/ListView&gt; 在MainActivity.java的源码文件里，在界面创建的时候（onCreate()当中），通过代码获取ListView； 123456789@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"TEST\", \"Weather app launched\"); ListView lv = (ListView) findViewById(R.id.weather_more_info_list);&#125; java源码通过R.id.weather_more_info_list，将布局文件中的ListView找了出来，转换成了可以通过java代码操作的对象。 创建一个Adapter负责为ListView提供数据。Android SDK提供了很多类型的Adapter，ArrayAdapter CursorAdapter SimpleAdapter等等，它们都是BaseAdapter的子类，简化了Adapter的使用。 要显示的数据和显示这项数据项的布局要设置给Adapter， 12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ...... //每一项要显示的数据是一个字符串，这里设置显示3项 String data[] = &#123;\"a\", \"b\", \"c\"&#125;; //指定显示的数据内容，以及显示每项内容的布局文件 ArrayAdapter adapter ＝ new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1 , data);&#125; Android SDK提供了一些常用的数据项布局方式android.R.layout.simple_list_item_1 android.R.layout.simple_list_item_2等等。我们也可以自己设计每一项的布局方式。 将Adapter设置给ListView，数据将以列表的形式被展示， 12345@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ...... lv.setAdapter(adapter);&#125; 为显示的每个item添加，点击时代响应处理函数； 1234567891011@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; ...... lv.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; //添加需要响应的操作 &#125; &#125;);&#125; 综合以上的代码，就是， 123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; ...... ListView lv = (ListView) findViewById(R.id.list_view); String data[] = &#123;\"a\", \"b\", \"c\"&#125;; ArrayAdapter adapter ＝ new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1 , data); lv.setAdapter(adapter); lv.setOnItemClickListener(new OnItemClickListener() &#123; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; //添加需要响应的操作 &#125; &#125;);&#125; 最后的界面效果就是这样， 运行以后，就能看到a b c以列表的形式，在界面上展现出来了。 如果需要展示的数据有变化，就需要更新ListView。 ListView的更新需要在主线程进行（UI线程）。如果在其他线程更新，系统有可能报错，并提示你“不能在非UI线程更新界面元素”。 所以修改了Adapter中要展示的数据后，需要使用Adapter的notifyDataSetChanged()通知主线程自动刷新界面; 例如， 1234567891011121314//要显示的数据用链表的形式保存；List data ＝ new ArrayList&lt;String&gt;();data.add(\"a\");data.add(\"b\");data.add(\"c\");//指定显示的数据内容，以及显示每项内容的布局文件ArrayAdapter adapter ＝ new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1 , data); ......//修改显示的数据项data.add(\"d\");//使用notifyDataSetChanged()通知主线程刷新界面ArrayAdapter.notifyDataSetChanged(); 自定义Adapter虽然Android SDK为我们提供了好几种现成的Adapter使用，但有时它们也并不能完全符合我们的要求，比如满足我们希望的天气信息项界面。 因此，我们准备自定义一个Adapter。 其实SimpleAdapter是可以满足要求的，但是为了下一阶段能容易的使用Material Design推荐的列表控件，我就先讲一讲如何自定义Adapter，降低后面的学习难度。 定义数据项的布局为了让列表的数据项按照我们设计的模样显示，我们需要为它设计一个布局，把天气相关的更多信息展示上去。 数据项的布局定义在res\\layout\\weather_more_info_item_layout.xml文件中（如何创建这种布局文件，前面已经介绍过了）。 数据项布局的方案如下， 元素 控件 属性 id名称 图标 ImageView 左边距 16dp 内容居中 weather_more_info_icon 内容描述 TextView 左边距 72dp 内容垂直居中 weather_more_info_description 取值 TextView 有边距 16dp 内容垂直居中 weather_more_info_value 数据项的整体布局 FrameLayout 高度48dp 无 数据项是一个FrameLayout，放到这个布局中的所有元素就像千层饼一样，都是一层一层堆叠起来的； 高度是设计规范中定义的48dp， 12345&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"48dp\"&gt;&lt;/FrameLayout&gt; 图标使用ImageView控件，给它的android:scaleType属性设置center，让缩略图垂直居中放置，图片预设成ic_air_quality；左边距是16dp； 12345678&lt;ImageView android:id=\"@+id/weather_more_info_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_air_quality\" android:scaleType=\"center\" android:layout_gravity=\"center_vertical\" android:layout_marginLeft=\"16dp\"/&gt; 内容描述使用TextView控件，它的左边距是72dp，垂直居中放置，字体的大小和颜色按照设计的规范来指定， 123456789&lt;TextView android:id=\"@+id/weather_more_info_description\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"湿度\" android:layout_marginLeft=\"72dp\" android:layout_gravity=\"center_vertical\" android:textSize=\"16sp\" android:textColor= \"#DE000000\"/&gt; 取值使用TextView控件，它的右边距是16dp，垂直居中、整体靠右放置-center_vertical|right，字体的大小和颜色按照设计的规范来指定， 123456789&lt;TextView android:id=\"@+id/weather_more_info_value\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"30%\" android:layout_marginRight=\"16dp\" android:layout_gravity=\"center_vertical|right\" android:textSize=\"14sp\" android:textColor= \"#8A000000\"/&gt; 综合起来，如下面的布局源码， 12345678910111213141516171819202122232425262728293031323334&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"horizontal\" android:layout_width=\"match_parent\" android:layout_height=\"48dp\"&gt; &lt;ImageView android:id=\"@+id/weather_more_info_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_air_quality\" android:scaleType=\"center\" android:layout_gravity=\"center_vertical\" android:layout_marginLeft=\"16dp\"/&gt; &lt;TextView android:id=\"@+id/weather_more_info_description\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"湿度\" android:layout_marginLeft=\"72dp\" android:layout_gravity=\"center_vertical\" android:textSize=\"16sp\" android:textColor= \"#DE000000\" /&gt; &lt;TextView android:id=\"@+id/weather_more_info_value\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"30%\" android:layout_marginRight=\"16dp\" android:layout_gravity=\"center_vertical|right\" android:textSize=\"14sp\" android:textColor= \"#8A000000\"/&gt;&lt;/FrameLayout&gt; 最后效果图： 实现同一个布局效果的方案可以有很多种。有的方案在代码上很容易实现，有的方案可能还会考虑到布局刷新的效率。随着开发经验的增多，对各种布局实现原理的深入理解，大家会进一步的加深对布局的认识。 定义数据项的数据结构为了提供显示的数据内容，要先定义一个存放数据的数据结构-WeatherMoreInfo。 首先要重新创建一个java源文件，定义数据结构的类， 给类命名WeatherMoreInfo， 在java目录对应的包目录下，就生成了WeatherMoreInfo.java文件。 我们要在这个类里面存放3个数据：图标、名称、数值。 组件名称 存储类型 说明 字段名称 图标 int 存储图标对应的资源id typeResId 内容描述 String 数据项的名称，描述含义 description 数值 String 显示名称对应的数据取值 value 1234567public class WeatherMoreInfo &#123; public int typeResId = 0; public int description; public String value = \"\";&#125; 数据结构的定义我们暂时就到这里，这个结构在后面还会做出调整，需要和网络端的数据进行配合。我们先到此处，只要能显示列表就可以了。 定义Adapter现在开始自定义Adapter-WeatherMoreInfoAdapter。 Adapter都是继承自BaseAdapter的，我们这里的Adapter准备继承自它的一个子类ArrayAdapter。因为ArrayAdapter在最原始的基础上作出了改进，我们再在它的基础上做一些小的调整就可以用了，而不用完全从头来过。 创建WeatherMoreInfoAdapter.java的新类。 继承ArrayAdapter，将显示的数据类型指定成WeatherMoreInfo；重新构造函数，传入Context，数据项布局使用的布局ID，要显示的数据列表；重写它的getView()方法； 12345678910111213public class WeatherMoreInfoAdapter extends ArrayAdapter&lt;WeatherMoreInfo&gt; &#123; public WeatherMoreInfoAdapter(Context context, int resource, List&lt;WeatherMoreInfo&gt; objects) &#123; super(context, resource, objects); &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; return null; &#125;&#125; 在构造函数中，保存好布局ID以后使用，通过Context获取Inflater，为以后数据项布局的创建做准备， 12345678private final LayoutInflater mInflater;private final int mResource;public WeatherMoreInfoAdapter(Context context, int resource, List&lt;WeatherMoreInfo&gt; objects) &#123; super(context, resource, objects); mInflater = LayoutInflater.from(context); mResource = resource;&#125; 在getView()函数中，创建数据项的布局，并为他们赋值，最后将这个布局返回给ListView，让它显示， 1234567891011121314151617181920@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; if (convertView == null) &#123; convertView = mInflater.inflate(mResource, parent, false); &#125; WeatherMoreInfo item = getItem(position); ImageView icon = (ImageView) convertView.findViewById(R.id.weather_more_info_icon); icon.setImageResource(item.typeResId); TextView description = (TextView) convertView.findViewById(R.id.weather_more_info_description); description.setText(item.description); TextView value = (TextView) convertView.findViewById(R.id.weather_more_info_value); value.setText(item.value); return convertView;&#125; 这里的convertView就是数据项所代表的那个布局，当ListView刚创建，还没有产生任何数据项的时候，它就是为null的，此时我们就需要创建一个布局，并通过getView()将这个布局返回给ListView。 假如ListView上的数据项布局已经足够了，那么这里传入的convertView就不会再是null，而是之前的某个数据项布局，我们就不必为此重新创建了，只需要更新上面的内容就好。这样提高了界面刷新的效率。 当然，这里还能通过其他方法减少使用findViewById()，进一步提高效率，不过目前就不改进了，先把功能实现完成。 Adapter终于完成了。 使用Adapter现在看看这个Adapter怎么用。 在MainActivity创建之时，我们在onCreate()中创建并设置WeatherMoreInfoAdapter， 123456789101112131415161718192021public class MainActivity extends AppCompatActivity &#123; //保存ListView控件 private ListView mWeatherMoreInfoListView; //保存更多信息到列表当中 private List&lt;WeatherMoreInfo&gt; mWeatherMoreInfoList; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ...... mWeatherMoreInfoListView = (ListView) findViewById(R.id.weather_more_info_list); //创建保存数据的列表，数据暂时没有 mWeatherMoreInfoList = new ArrayList&lt;&gt;(); //创建一个还没有添加入数据的Adapter WeatherMoreInfoAdapter adapter = new WeatherMoreInfoAdapter(MainActivity.this, R.layout.weather_more_info_item_layout, mWeatherMoreInfoList); mWeatherMoreInfoListView.setAdapter(adapter); &#125;&#125; 在创建Adapter的时候，把weather_more_info_item_layout.xml代表的布局传给了Adapter，Adapter将使用它来生成每个数据项的界面。 添加一些虚假的数据到Adapter中，并使用notifyDataSetChanged()刷新看看效果， 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ...... WeatherMoreInfo data1 = new WeatherMoreInfo(); data1.typeResId = R.mipmap.ic_wind_level; data1.description = \"风力\"; data1.value = \"3级\"; mWeatherMoreInfoList.add(data1); WeatherMoreInfo data2 = new WeatherMoreInfo(); data2.typeResId = R.mipmap.ic_wind_direction; data2.description = \"风向\"; data2.value = \"东南\"; mWeatherMoreInfoList.add(data2); WeatherMoreInfo data3 = new WeatherMoreInfo(); data3.typeResId = R.mipmap.ic_humidity_level; data3.description = \"湿度\"; data3.value = \"60%\"; mWeatherMoreInfoList.add(data3); WeatherMoreInfo data4 = new WeatherMoreInfo(); data4.typeResId = R.mipmap.ic_air_quality; data4.description = \"空气质量\"; data4.value = \"重污染\"; mWeatherMoreInfoList.add(data4); WeatherMoreInfo data5 = new WeatherMoreInfo(); data5.typeResId = R.mipmap.ic_sport_level; data5.description = \"运动\"; data5.value = \"不合适\"; mWeatherMoreInfoList.add(data5); WeatherMoreInfo data6 = new WeatherMoreInfo(); data6.typeResId = R.mipmap.ic_ultraviolet_level; data6.description = \"紫外线\"; data6.value = \"强\"; mWeatherMoreInfoList.add(data6); adapter.notifyDataSetChanged();&#125; 至此，视频列表的界面就能看到视频列表了。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"8 天气预报的布局","slug":"4_开发/8_天气预报的布局","date":"2017-02-02T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/8_天气预报的布局/","link":"","permalink":"http://booktest.anddle.com/4_开发/8_天气预报的布局/","excerpt":"","text":"天气预报的布局现在我们开始进行天气预报区域的布局。 可以看出，这个区域，由5个完全一样的组件组合而成。只要我们完成一个组件-天气预报项的布局，再把这个布局复制粘贴，很容易就完成了。 天气预报项在layout目录上点击右键，选择New -&gt; Layout resource file。 输入布局文件的名字forcast_item， 一个新的布局文件forcast_item.xml就被创建到了res\\layout目录下了。 天气预报项的整体布局分成上中下3段，依次纵向排列，分别显示文字、图片、文字。 区域名称 区域高度 选用控件或布局 日期 占用剩余空间的上半部分 TextView 天气 根据资源图片的高度确定 ImageView 温度范围 占用剩余空间的下半部分 TextView 修改forcast_item.xml布局文件： 给LinearLayout设置android:orientation=&quot;vertical&quot;属性； 让LinearLayout内部的组件，水平居中android:gravity=&quot;center_horizontal&quot;； 从上到下，依次放入TextView ImageView TextView；它们的布局属性如此设置： 日期 天气 温度范围 layout_height 0dp wrap_content 0dp layout_width wrap_content wrap_content wrap_content layout_weight 1 无 1 id名称 forcast_date forcast_icon forcast_temperature 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center_horizontal\"&gt; &lt;TextView android:id=\"@+id/forcast_date\" android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt; &lt;ImageView android:id=\"@+id/forcast_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;TextView android:id=\"@+id/forcast_temperature\" android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:layout_weight=\"1\"/&gt;&lt;/LinearLayout&gt; 这里使用到了LinearLayout给内部组件使用到属性layout_weight。 layout_weight表示一个组件的重要性，拥有这个属性的组件将根据它的数值，按照比例分得剩余空间。 就这里来讲，日期与温度范围都具有1的权重，因此它们将按照1:1的比例，瓜分除去天气占据的高度后，剩下的空间高度。 为日期预设上显示的内容： 设置TextView显示的文字内容，android:text=&quot;明天&quot;； 设置TextView文字的大小，android:textSize=&quot;14sp&quot;； 设置TextView文字的颜色，android:textColor=&quot;#de000000&quot;； 让文字显示居中，android:gravity=&quot;center&quot;; 123456789&lt;TextView android:id=\"@+id/forcast_date\" android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:text=\"明天\" android:textColor=\"#DE000000\" android:textSize=\"14sp\" android:gravity=\"center\"/&gt; 为天气预设上显示的图片： 设置android:src=&quot;@mipmap/ic_sunny_cloudy_s&quot;，加上图标； 设置android:scaleType=&quot;center&quot;，将图标正好占满控件的区域； 123456&lt;ImageView android:id=\"@+id/forcast_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_sunny_cloudy_s\" android:scaleType=\"center\"/&gt; 为温度范围预设上显示的内容： 设置TextView显示的文字内容，android:text=&quot;17℃～25℃&quot;； 设置TextView文字的大小，android:textSize=&quot;12sp&quot;； 设置TextView文字的颜色，android:textColor=&quot;#8a000000&quot;； 让文字显示居中，android:gravity=&quot;center&quot;; 123456789&lt;TextView android:id=\"@+id/forcast_temperature\" android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:text=\"17℃～25℃\" android:textColor=\"#8a000000\" android:textSize=\"12sp\" android:gravity=\"center\"/&gt; 使用include标签接下来就可以给天气预报区域所在的LinearLayout， 设置上水平显示的属性android:orientation=&quot;horizontal&quot;； 再把天气预报项的布局方式重复5次，放入其中。这就完成了这个区域的布局了； 1234567891011121314151617181920212223242526&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:orientation=\"horizontal\"&gt; &lt;LinearLayout ......&gt; &lt;/LinearLayout&gt; &lt;LinearLayout ......&gt; &lt;/LinearLayout&gt; &lt;LinearLayout ......&gt; &lt;/LinearLayout&gt; &lt;LinearLayout ......&gt; &lt;/LinearLayout&gt; &lt;LinearLayout ......&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 哈哈，这样的做法真是简单又暴力。 不过，对于这种需要重复使用到的布局，Android SDK提供了一个非常方便的标签include。使用它就可以把一个布局重复的布局文件引入到另一个布局文件当中。 在LinearLayout当中使用多个include标签； 给它们的layout属性设置上要重复使用的布局文件forcast_item；并给每个标签设置一个id。 123456789101112&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:orientation=\"horizontal\"&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item1\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item2\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item3\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item4\" /&gt; &lt;include layout=\"@layout/forcast_item\" android:id=\"@+id/forcast_item5\" /&gt;&lt;/LinearLayout&gt; 这时还看不到期待的效果，原因是forcast_item当中的LinearLayout设置的宽度是match_parent-占据整个屏幕。我们需要让这些天气预报项平均占据屏幕的宽度，所以需要给forcast_item.xml中的LinearLayout设置上android:layout_weight=&quot;1&quot;的属性， 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:gravity=\"center_horizontal\" android:layout_weight=\"1\"&gt; ...... &lt;/LinearLayout&gt; 给天气预报区域的左右两边，加上16dp的边距； 12345678910&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:orientation=\"horizontal\" android:layout_marginLeft=\"16dp\" android:layout_marginRight=\"16dp\"&gt; ......&lt;/LinearLayout&gt; 从这个例子可以看出，include的作用就是把它自己layout属性指定的布局替换到include的位置。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"7 天气详情的布局","slug":"4_开发/7_天气详情的布局","date":"2017-02-01T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/7_天气详情的布局/","link":"","permalink":"http://booktest.anddle.com/4_开发/7_天气详情的布局/","excerpt":"","text":"天气详情的布局整体布局完成之后，我们开始进行天气详情区域的布局。 这个区域由天气图标、当前温度、当日温度范围、地理位置等4个元素组成。我们可以选用Android SDK提供的现有控件，完成布局。 区域名称 区域高度 选用控件或布局 天气图标 100dp ImageView 当前温度 文字的字体决定 TextView 当日温度范围 文字的字体决定 TextView 地理位置 文字的字体决定 TextView 这些区域的对齐分配，我们可以借助嵌套更多的LinearLayout来完成， 上下区域的划分将天气图标、当前温度、当日温度范围归为上半区域，地理位置归为下半区域， 使用LinearLayout进行分割; 给天气详情区域设置Primary Color-#3F51B5作为背景颜色； 上半区域设置高度android:layout_height为100dp，上边距android:layout_marginTop为24dp； 下半区域使用所有剩下的空间； 123456789101112131415161718192021&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"244dp\" android:background=\"#3F51B5\" android:orientation=\"vertical\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:layout_marginTop=\"24dp\" android:background=\"#FFFF0000\"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#FF00FF00\"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 天气图标与当日温度天气图标与当日温度左右并列， 为LinearLayout设置horizontal属性，使其内部的布局或控件水平排列，把它的高度修改成wrap_content； 将ImageView放置在左边，宽度设置成150dp，高度设置成wrap_content； 同时给ImageView设定一个id-android:id=&quot;@+id/weather_icon&quot;。 设定了id，以后再代码中获取它对应的控件就很方便了，只需要像这样， 1ImageView im = (ImageView) findViewById(R.id.weather_icon); java源码通过R.id.weather_icon，将布局文件中的ImageView找了出来，转换成了可以通过java代码操作的对象。 将另一个LinearLayout放置在右边，宽度设置成150dp，高度设置成100dp； 123456789101112131415161718192021&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"24dp\" android:background=\"#FFFF0000\" android:orientation=\"horizontal\"&gt; &lt;ImageView android:id=\"@+id/weather_icon\" android:layout_width=\"150dp\" android:layout_height=\"100dp\" android:background=\"#FFFFFF00\"/&gt; &lt;LinearLayout android:layout_width=\"150dp\" android:layout_height=\"100dp\" android:background=\"#FF0000FF\"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 此时布局很紧促，并且没有居中对齐，需要做进一步的设置， 为LinearLayout设置android:gravity=&quot;center&quot;属性；让它内部的组件都能够居中放置； 给温度区域设置上20dp的左边距android:layout_marginLeft； 1234567891011121314151617181920212223&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"24dp\" android:background=\"#FFFF0000\" android:orientation=\"horizontal\" android:gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/weather_icon\" android:layout_width=\"150dp\" android:layout_height=\"100dp\" android:background=\"#FFFFFF00\"/&gt; &lt;LinearLayout android:layout_width=\"150dp\" android:layout_height=\"100dp\" android:background=\"#FF0000FF\" android:layout_marginLeft=\"20dp\"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 添加图片将天气图标设置给ImageView， 添加android:src属性，把图标id-ic_sunny_cloudy_l设置给它； 添加android:scaleType属性，设置值为center； 1234567891011121314151617181920212223&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"24dp\" android:orientation=\"horizontal\" android:gravity=\"center\"&gt; &lt;ImageView android:id=\"@+id/weather_icon\" android:layout_width=\"150dp\" android:layout_height=\"100dp\" android:src=\"@mipmap/ic_sunny_cloudy_l\" android:scaleType=\"center\"/&gt; &lt;LinearLayout android:layout_width=\"150dp\" android:layout_height=\"100dp\" android:background=\"#FF0000FF\" android:layout_marginLeft=\"20dp\"&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 添加温度使用LinearLayout将温度显示分为上下两个部分，显示温度的控件使用TextView 给LinearLayout的orientation设置为horizontal； 为LinearLayout设置android:gravity=&quot;center_horizontal&quot;属性；让它内部的组件都能够居中放置； 修改LinearLayout的高度为wrap_content; 放入2个TextView，用来分别当日温度和温度范围，并分别给它们指定id-current_temperature和temperature_range； 1234567891011121314151617181920212223242526272829&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"24dp\" android:orientation=\"horizontal\" android:gravity=\"center\"&gt; ...... &lt;LinearLayout android:layout_width=\"150dp\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"20dp\" android:orientation=\"vertical\" android:gravity=\"center_horizontal\"&gt; &lt;TextView android:id=\"@+id/current_temperature\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;TextView android:id=\"@+id/temperature_range\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 设置当前温度给当前温度设置上一个预设的显示内容： 设置TextView显示的文字内容，android:text=&quot;23°&quot;； 设置TextView文字的大小，android:textSize=&quot;56sp&quot;； 设置TextView文字的颜色，android:textColor=&quot;#b3ffffff&quot;； 1234567&lt;TextView android:id=\"@+id/current_temperature\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"23°\" android:textColor=\"#b3ffffff\" android:textSize=\"56sp\"/&gt; 设置温度范围给温度范围设置上一个预设的显示内容： 设置TextView显示的文字内容，android:text=&quot;17℃～25℃&quot;； 设置TextView文字的大小，android:textSize=&quot;24sp&quot;； 设置TextView文字的颜色，android:textColor=&quot;#ffffffff&quot;； 1234567&lt;TextView android:id=\"@+id/temperature_range\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"17℃～25℃\" android:textColor=\"#ffffffff\" android:textSize=\"24sp\"/&gt; 添加位置信息将TextView添加到下部的LinearLayout当中： 位置为垂直居中，给LinearLayout设置android:gravity=&quot;center_vertical&quot;； 设置TextView的左边距为24dp； 设置TextView显示的文字内容，android:text=&quot;成都； 设置TextView文字的大小，android:textSize=&quot;34sp&quot;； 设置TextView文字的颜色，android:textColor=&quot;#ffffffff&quot;； TextView的id设置成location 123456789101112131415&lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center_vertical\"&gt; &lt;TextView android:id=\"@+id/weather_location\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"24dp\" android:text=\"成都\" android:textColor=\"#ffffffff\" android:textSize=\"34sp\"/&gt;&lt;/LinearLayout&gt; 这个区域的界面设计只是在第1阶段的实现中会使用到。当进入到第2阶段-使用Material设计规范来实现的时候，是不需要这个布局的，因为安卓系统能自动实现这个信息的显示。 现在，天气详情的布局就全部完成了。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"6 界面的整体布局","slug":"4_开发/6_界面的整体布局","date":"2017-01-28T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/6_界面的整体布局/","link":"","permalink":"http://booktest.anddle.com/4_开发/6_界面的整体布局/","excerpt":"","text":"界面的整体布局从这一章节开始，我们终于可以开始使用Android Studio写代码了。 天气预报这个应用虽然功能很简单，但是对于从来没有接触过安卓开发的人来讲，开发完成还是需要很多步骤。为了减小学习的坡度，增加开发的阶段性成就感，我将天气预报分成2个阶段来开发， 第1阶段：暂时不考虑Material Design的各种限制，比如Appbar的滑动效果，界面的配色设置，字体的大小等等，先把功能实现了再说； 第2阶段：加入Material Design的种种要求，完善天气预报； 我们就从第一阶段开始。 Activity与布局Activity几乎是每个应用必有的组件，所以任何安卓应用的开发几乎都是从Activity开始的。 你甚至可以简单的认为，手机屏幕上能看到的整个界面，就是一个Activity。 使用Android Studio创建工程后，会默认为我们创建一个Activity组件。它继承自Android SDK的Activity或其派生类。 123class MainActivity extends Activity &#123; ......&#125; Activity界面具体该长成什么样，是通过布局文件决定的。它位于项目的res\\layout\\activity_main.xml文件中。 这个布局文件通过java源代码MainActivity.java中的setContentView()函数，设置到界面上。 12345@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main);&#125; 可以说xml布局文件，负责Activity的外观容貌；java源代码，负责Activity的逻辑控制。java控制着xml中的各个元素的显示逻辑。 接下来，我们天气预报界面的布局，就会在布局文件activity_main.xml中进行。 WeatherApp工程项目中的MainActicity继承自AppCompatActivity。AppCompatActivity也是Activity的子类，所以是没有问题的。这个AppCompatActivity作用是为了兼容各个版本的Android SDK而使用的，我们会在今后给出详细的介绍。 布局的划分整个布局被分成了以下几个部分： Appbar：占据高度56dp； 天气详情：显示当日的温度范围和实时天气，占据高度300dp - 56dp = 244dp；按照最终的设计，天气详情是需要放在Appbar里面的，但是第1阶段做了简化，所以将它单独拿出来了； 天气预报：显示未来5日的天气预报，占据高度100dp； 分割线：占据高度10dp； 相关信息：当日天气的相关信息，占据所有剩余空间的高度； Appbar的存在是由系统决定的，我们就不做修改了，主要是分配2～5的布局空间。 布局与控件界面设计需要先认识两类工具：控件Control与布局Layout。 控件Control就是我们常常看到的按钮 滑动条 文字显示区等等，它们就像房间里的家具，是界面设计的最小单位。为了简小界面开发的难度，SDK会提供很多现成的界面小组件供开发者使用。 布局Layout是一个可以容纳别的布局（或者控件）的容器。它就像是一个大的房间，房间里面可以放各种家具（控件），也可以再隔离成更多的房间（放入别的布局）。 不过两者有很多共同的地方，例如指定它们大小、边距的方式等等。 给天气预报设计布局，就是通过选用Android SDK中合适的布局和控件来实现的。 布局容器整个应用的内容都是放在一个大的布局Layout当中的。因此要首先确定这个最大的布局。 Android SDK提供了一个叫做LinearLayout的布局控件。它能够让存放于其中的其他控件按照首尾顺序，一个接一个的排队摆放。正好符合我们的要求。 编辑activity_main.xml文件，删除其中原有的TextView控件，删除RelativeLayout中的各种padding； 将原来的RelativeLayout修改成LinearLayout； 给LinearLayout增加android:orientation属性，其值设置成vertical–将它包含的内容以竖直方式排列; LinearLayout负责放置应用的整个内容，需要尽可能占用整个屏幕，因此使用match_parent指定布局的宽度和高度。 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.anddle.weatherapp.MainActivity\"&gt;&lt;/LinearLayout&gt; 现在通过预览窗口，可以看到界面变成了这样， 注意：文字WeatherApp所在的Appbar是系统自带的，并不是activity_main.xml中设计的。 在设置布局或者控件大小的时候，会使用它们的android:layout_width和android:layout_height属性， 123&lt;View android:layout_width=\"match_parent\" android:layout_width=\"wrap_content\"/&gt; 它们的值可以设定成， 特定的数值：例如5dp。当然也可以使用除了dp以外其他的尺寸单位，但是考虑到屏幕的像素密度不同，我们都使用dp为单位； match_parent：以父布局的宽度（或长度）为界，尽可能占据全部空间； wrap_content：以子布局或控件内容的宽度（或长度）为界，尽可能少占据空间； 容器的分配其他几个区域都占据了整个屏幕都宽度，只是高度各不相同， 区域名称 区域高度 选用控件或布局 天气详情 244dp LinearLayout 未来5日天气预报 100dp LinearLayout 分割线 10dp View 相关信息 剩余的所有高度 ListView View：是安卓系统中最为基本界面的组件，所有的布局与控件都是特殊的View（它们都是View的子类）。这里用来作为分割线。 ListView：是安卓SDK提供的列表控件，将数据项用列表的形式展现出来。给ListView布局增加一个id叫做weather_more_info_list。我们后面在详细的介绍用法。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/activity_main\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\"com.anddle.weatherapp.MainActivity\"&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"244dp\" android:background=\"#FFFF0000\"&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"100dp\" android:background=\"#FF00FF00\"&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"10dp\" android:background=\"#1F000000\" /&gt; &lt;ListView android:id=\"@+id/weather_more_info_list\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#FF0000FF\"&gt; &lt;/ListView&gt;&lt;/LinearLayout&gt; 为了明显的看到各个控件与布局占据的屏幕空间分布情况，我给每个控件或布局都添加上了android:background属性，给它们设置上了不同的颜色以示区别，后面再将它们移除。最后的效果如下， 安卓系统中的颜色数值，可以用4种方式表示， RGB：8位RGB数值。例如红色F00，绿色0F0，蓝色00F； ARGB：8位RGB数值，外加8位Alpha透明度值。例如透明度为8的红色8F00，绿色80F0，蓝色800F RRGGBB：16位RGB数值。例如红色FF0000，绿色00FF00，蓝色0000FF； AARRGGBB：16位RGB数值，外加16位Alpha透明度值。例如透明度为0F的红色0FFF0000，绿色0F00FF00，蓝色0F0000FF； 代码管理将修改的内容提交到GitHub上，这一步和之前的操作并没有任何的不同。 不过这里介绍一下你可能会遇到的意外情况：假如commit之后push之前，我发现自己commit的内容有问题，要撤销上一步的commit。这该怎么办？比如将commit时要记录的信息写错了，要退回到commit之前的状态。 改正的方法很简单： 在上一次正确的commit项上，点击右键； 选择Reset Current Branch to Here...; 在弹出的菜单项上，选择Mix（每种选择的效果都有对应的解释，Mix就是说返回commit之前的状态，并保留修改的内容），并点击Reset； 这样，整个commit就回到了未被提交时的状态。检查之后再做重新的commit。这一次就得小心仔细一些啦！ 假如你不仅commit了，而且还push到远端的仓库中了，要恢复该怎么办呢？ 答案是没办法了，你只能重新修改一次，再提交。之前的修改已经被记录在案了。所以每次push一定要注意，不然你的合作开发者一定会看到你的粗心大意。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"5 资源的导入","slug":"4_开发/5_资源的导入","date":"2017-01-27T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/5_资源的导入/","link":"","permalink":"http://booktest.anddle.com/4_开发/5_资源的导入/","excerpt":"","text":"资源的导入在前面讲解产品原型设计的章节中，我们已经创建出了各种开发时需要使用的各种图标了，包括应用图标、系统图标等等。 图标导入现在，我们先把开发过程中要使用到的图片资源添加到Android Studio工程目录当中。 将Sketch创建的静态高保真原型中的图标，根据导出的尺寸，将它们分类整理到对应的文件夹当中， 打开天气预报所在的Android Studio的工程文件夹-app -&gt; src -&gt; main -&gt; res，将图片替换到对应的mipmap目录当中； 重新部署应用到设备上，桌面上的天气预报应用图标，已经从以前的安卓机器人，变成了新的图标了， 版本管理我们新增了约90个图片资源，需要将它们加入到Git的版本控制之中。 查看Version Control: -&gt; Local Changes -&gt; browse; 在弹出的对话框中，选中需要加入版本控制的90个图片文件，点击左边的+； 需要管理的文件被添加到了stage当中； 之后再把这些改动，按照上一张讲到提交到本地库和远程GitHub当中的方式进行操作就可以了； 图片的使用对于那些导入的图片资源，Android Studio会做进一步处理，自动生成一个R.java文件，文件中给每一张图片生成一个对应的id值。 12345678910111213141516171819202122232425public final class R &#123; public static final class mipmap &#123; public static final int ic_air_quality=0x7f030000; public static final int ic_cloudy_l=0x7f030001; public static final int ic_cloudy_s=0x7f030002; public static final int ic_fog_l=0x7f030003; public static final int ic_fog_s=0x7f030004; public static final int ic_humidity_level=0x7f030005; public static final int ic_launcher=0x7f030006; public static final int ic_rainy_l=0x7f030007; public static final int ic_rainy_s=0x7f030008; public static final int ic_snow_l=0x7f030009; public static final int ic_snow_s=0x7f03000a; public static final int ic_sport_level=0x7f03000b; public static final int ic_sunny_cloudy_l=0x7f03000c; public static final int ic_sunny_cloudy_s=0x7f03000d; public static final int ic_sunny_l=0x7f03000e; public static final int ic_sunny_s=0x7f03000f; public static final int ic_ultraviolet_level=0x7f030010; public static final int ic_wind_direction=0x7f030011; public static final int ic_wind_level=0x7f030012; &#125;&#125; 当我们要使用对应资源的时候，直接使用java代码： 1int id = R.mipmap.ic_launcher; 就可以了。 通过这种方式，完成了资源到代码的转换。 资源的条件命名法图片资源文件夹的命名方式很有特点，在主名字之后，使用-间隔了一些扩展名字。例如， mipmap-hdpi mipmap-xhdpi 目录名用“－”增加了限制条件。也就是给目录里资源的使用增加了约束。 这里用mipmap-hdpi文件夹举例说明：如果当前的设备属于hdpi类型的屏幕，那么在使用图片的时候，系统优先使用其中的图片。 除了上面的目录结构，有时你还会看到如下的目录形式： mipmap-hdpi：给属于hdpi的设备使用; values-zh：给当前语言是中文的系统使用; layout-land：给处于横屏状态的系统使用; 图片的优化屏幕密度选择性匹配并不是说一定要为所有的屏幕密度做对应图片尺寸的匹配，因为如果做全部匹配会让程序的体积快速增大。 大多数时候，我们会选择先做高清晰度的尺寸，例如xxhdpi。其他屏幕密度的设备需要使用资源时，就会把xxhdpi中的资源，做适度的缩放，以达到匹配的效果。 对于个别系统缩放也达不到显示要求的图片，才做针对不同屏幕密度的配套图片。 我们的天气预报把所有尺寸的屏幕密度都做了适配。 矢量图标另外，对于很多系统图标，我们也可以不使用png图片，而采用矢量图，让安卓系统绘制图标。这样一来，程序的体积可以跟小，显示效果也更为出众。 不过大家初次接触安卓开发，为了减少不必要的枝节，我就隐去了这部分内容，将来再和大家详细的讲述。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"4 版本管理","slug":"4_开发/4_版本管理","date":"2017-01-26T01:00:00.000Z","updated":"2017-02-17T03:01:25.000Z","comments":false,"path":"4_开发/4_版本管理/","link":"","permalink":"http://booktest.anddle.com/4_开发/4_版本管理/","excerpt":"","text":"版本管理前面已经提到了，非常有必要对开发的代码进行管理。那么进行版本管理到底什么时候使用呢？ 我总结了使用版本管理的主要场景，有以下3种： 对于个人开发者，版本管理能记录开发的变迁。它记录了所有文档的修改记录，就好比玩游戏时，我们都会时刻存档，就怕哪一次不小心，控制的角色挂了；假如不存档，出了问题，必须得从新开始。 如果使用了版本管理，就可以随时保存文档修改的进度。一旦文档任何时候出现了问题，或者希望快速还原到之前某个特定的状态，都可以很容易的切换过去。省去了程序员不少麻烦，毕竟谁也记不清哪年哪月哪日我添加了一段什么代码，目的是什么，而正是这段代码引起了bug，搞得我现在大脑崩溃。 当多个程序员开发同一个项目的时候，版本管理工具能很好的协调彼此的工作，让大家开发的代码不会冲突、互相干扰，即使出现了问题，也能很快找到原因。 比如程序员A在他的开发代码中修改了work.java中第15行的内容，同时程序员B在他的开发代码中修改了work.java中第20行的内容。两人把修改提交保存的时候，版本管理工具，会把两人的修改合并起来。 如果程序员A在他的开发代码中修改了work.java中第15行的内容，同时程序员B在他的开发代码中也修改了work.java中第15行的内容。两人把修改的内容提交保存的时候，版本管理工具，会发现两人的修改冲突，告诉A和B，让他们两协商解决问题。 文档的修改积累到一定程度，比如说完成了设计的所有内容，就可以设置一个大的节点。后继的开发可以分成两支：一支继续添加新的功能；一支修复现有程序的bug。 管理的工具为了满足前面提到使用场景，在软件开发的不同历史阶段，出现了不同的版本管理工具：从CVS，到SVN，再到现在使用最广泛的Git。 早期的版本控制软件存在的各种缺点，都被后来的代替者解决了。在安卓的开发中，基本上都在使用Git作为版本控制工具。 Git是Linux之父Linus Torvalds亲自开发的工具，有着高效的管理能力。它最为基本的运作思路大致如下： 仓库Repository是一个Git项目的容器，里面存放着文档（包括代码）、以及各个文档的历史修改信息； 仓库Repository可以存在于网络端，也可以存在于本地电脑当中； 仓库有两种获取的方式，一个是clone网络端已有的；一个是在本地电脑上自行创建，再通过网络提供给别人访问； 假如对本地的仓库内容进行了修改，要保存修改进度的时候， 要先将这些修改放到stage当中， 然后提交-commit到本地的仓库中，此时会产生一个全局唯一识别码-Commit ID，就像f27af79； 将commit后的内容推送push到网络端，而这个Commit ID就代表你这次提交的唯一标记； 假如推送的时候，自己修改的代码和仓库中的代码出现了冲突Conflit（因为修改了同一处的代码导致），那么推送者就需要查看代码、找到修改这段代码的提交者商量修改方案，解决冲突； 其他开发者假如clone了这个仓库，就能看到Commit后的各种修改，并通过拉取pull的操作从网络端把更新同步到自己本地的代码当中； 假如同步代码的过程中，自己的代码和别人的修改发生了冲突Conflit，那么拉取者就需要查看代码、找到修改这段代码的提交者商量修改方案，解决冲突； 除此之外，Git还拥有软件工程方面的实用技巧，例如创建开发分支Branch，给代码打标签Tag。 更加详细的内容，可以参考这里。里面还列举出了各个平台下可以选择的图形化工具。 Github的使用Github几乎是全世界程序员都知道的项目托管平台，我们可以把代码放在这个平台上。整个项目的托管就是基于Git的原理实现的。 Github在Git管理中充当着网络端的功能，扮演中心服务器的角色，让我们可以随时更新代码、提交代码，分享代码。 而Android Studio具有对Github平台的原生支持，让我们在开发的时候能够无缝的加入对软件版本控制的管理功能。 Github的注册打开Github的官网，按照指示很容易的注册一个账号。 登陆账号后，可以看到你现在具有的仓库-Repository， 我之前已经创建过几个免费仓库了，所以列表里会将它们呈现出来。如果是新注册的账号，这里应该是空的。 Android Studio的配置现在我们来把之前创建的天气预报工程，托管到Github上： 启动工具栏的VCS -&gt; Import into Version Control -&gt; Share Project on Github； 在弹出的窗口中，根据提示输入Github上的账户名和密码； 输入项目的名称WeatherApp和项目描述，选择Share； 确认要添加到管理中的文件（代码、配置、资源等文件），并给这次提交添加描述信息； 刷新Github上的个人主页，可以看到新添加的项目仓库WeatherApp已经出现在那里了， 此时看看Android Studio的Version Control窗口，就能看到当前的代码管理情况， Android Studio的Git管理提交与推送入库Git版本管理有很多用法，这里我们先介绍两个最常使用的功能commit与push。 假如我们修改了WeatherApp的MainActivity.java， LocalChanges选项卡会将当前发生了变化的、被版本管理记录的文件列出来， 点击提交commit按钮，会将修改过的文件放入stage状态， 并展示当前要提交commit文件的状态，让我们再次确认。当我们点击被修改过的文档时，Android Studio会为我们展示当前修改后的文档与修改前的文档有哪些异同。让我们在最后提交之前，再次检查确认一次， 检查无误后，选择提交并推送入库-Commit and Push， 假如没有冲突发生，就能看到提交成功，版本控制增加新的节点， Github上项目对应的代码页，也会更新， 其他Android Studio还提供了创建分支Branch、创建标签Tag、以及在不同节点上来回切换的功能，这里就不详细描述了。 因为这些内容如果没有实际的例子，讲起来会很枯燥。我会在开发的过程中根据需要穿插进响应的内容，这样大家理解起来就会非常的方便了。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"3 应用的创建与部署","slug":"4_开发/3_应用的创建与部署","date":"2017-01-25T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"4_开发/3_应用的创建与部署/","link":"","permalink":"http://booktest.anddle.com/4_开发/3_应用的创建与部署/","excerpt":"","text":"应用的创建与部署现在我们开始创建一个全新的项目工程-天气预报，并在编译后让它运行到真实的设备上。 创建应用工程运行Android Studio， 启动Android Studio，选择Start a new Android Projcet； 在Application name栏，为应用取个名字为WeatherApp； 在Company Domain栏，按照网址的形式填上anddle.com－－当然，你也可以根据自己的喜好填上别的域名； 在Project location栏，填写应用存放的位置，可以选择任意你希望存放项目工程的目录。 在下一步中，勾选上Phone and Tablet； Minimum SDK的选择，要与调试设备的安卓版本尽量一致，我们这里至少要是Android 5.0以上， *手机版本与API等级的对应关系如下： 下一步后，选择Empty Activity， 选择下一步后，开始设置Activity相关的信息； 在Activity Name栏，Activity采用默认的名字MainActivity； 在Layout Name栏，layout文件也采用默认的名字activity_main； 勾选上Backwards Compatiblility； Activity代表一个应用的主界面；而Activity具体长什么样子，就是靠布局文件Layout来指定的，二者是互相关联的关系。 Activity与Layout将在后面做详细的介绍。 选择完成后，工程也就创建完成， *因为Android Studio是第一次创建项目工程，因此需要连接网络下载一些组件，需要多等待一些时间。一旦下载成功，以后创建工程就不会花费这些时间了。 AS界面初步Android studio是Google为Android应用开发提供的一个强大的集成开发环境（IDE），有着非常多的帮助开发者进行开发的工具。 虽然Android应用也可以使用Eclipse开发，但是Android Studio将是Google未来唯一长期支持的开发工具。 Android Studio启动并打开工程后它的默认布局大体如下： 这些布局并不是一成不变的，我们可以通过拖动它们，调整它们的位置和大小，可以隐藏一些区域，在需要这些区域的时候再显示它们。 工程目录浏览当前的项目工程是最经常遇到的，Android Studio提供了多种对项目查看的方式， 它们从不同的角度来展示一个工程的方方面面。大家可以切换看看，不同的效果。 Project浏览方式当选择Project浏览方式的时候，它就像资源管理器的树形结构展开。所以当你希望看看磁盘上实实在在存在的关于这个项目的文件夹和目录的时候，就可以使用Projcect浏览方式， app文件夹：这是工程产生后，Android Studio自动创建的module所在文件夹。 Module是Android Studio工程中的一个功能单位。我们应用程序的源码和资源文件就放在这个module当中。 目前来说，我们需要使用到并修改到的内容，都在这个文件夹里面。其它的可以暂时不管。 src文件夹里面有三个子文件夹：androidTest、test和main。androidTest和test从名字就知道，里面放的是和测试我们程序相关的内容。目前我们将重点放到介绍开发上，测试的内容以后再讲。 main文件夹分了java和res两支，java存放的是java源代码，res存放的是资源文件。 main文件夹下面的AndroidManifest.xml文件是当前安卓应用自己的配置文件，我们将在开发过程当中重点详细的介绍。 Android浏览方式这是安卓安卓程序的逻辑功能划分的浏览方式，将配置文件（manifest文件）、代码（java文件）、资源（图片、字符串、布局文件等等）分类存放，显得非常整洁， 刚开始，我们就使用Project和Android两种浏览方式吧。随着经验的增加，会逐步发现其他浏览模式的方便之处。 UI所见即所得通过Android浏览方式，打开res -&gt; layout-&gt; activity_main.xml，会出现对应的设备上的预览效果， 当选择不同的预览设备时，预览界面会根据不同的设备做相应的变化。这个功能在做多尺寸设备的界面布局设计时非常有用。 暗黑主题在Android Studio中，还有一个我们程序员非常喜欢使用的暗黑主题， 启动设置，选择Appearance -&gt; Theme; Theme切换成Darcula就可以了; 是不是很酷呢？ 其他Android Studio还有很多实用的功能，比如资源引用的实时预览、代码自动补完、代码版本管理、各种快捷按键方式。很多内容需要大家自己去揣摩。 在后继的开发当中，我将会穿插人更多实用的特性介绍。 部署应用项目创建成功后，我们需要把它生编译成Apk，然后部署到设备上运行。 这需要手机和电脑两方面的配合。 设置要进行真实设备上的调试，需要修改手机上的原始设置。 默认情况下，设备端的调试模式是被关闭的，我们需要在设备的设置中，将这个功能打开。虽然各种品牌的手机不同，但是它们的设置菜单中都会有一个开发者选项。 我们首先要找到开发者选项。在Google Nexus设备上这个选项是被隐藏的， 需要进入到设置-&gt;关于手机； 连续点击“版本号”，将隐藏的开发者模式打开， 启用开发者模式后，打开“USB调试”功能， 之后将手机和电脑用USB数据线连接起来。 如果连接的是MacOS系统，手机就能直接被识别了；如果这是在Windows系统中，还要为连接上的设备安装ADB驱动。 在“我的电脑”上点鼠标右键，选择“管理”，打开设备管理器，可以看到没有安装驱动的设备， 为它更新驱动，选择“浏览计算机查找”， 驱动存放在Android SDK所在目录的extras\\google\\usb_driver下面， 点击确定后，驱动很快就安装成功了. 此时我们点击Android Studio的Android Monitor窗口，就能看到这个连接上的设备了，这个窗口还输出了手机端打印的运行信息。 部署现在开始部署应用到设备上运行， 点击工具栏上方绿色的小三角或者虫子背景的绿色小三角，程序就开始编译并准备部署到我们的设备上了， 绿色的小三角的含义是：以非调试状态运行程序；虫子背景的绿色小三角的含义是：以调试状态运行程序； 让我选择要部署的设备，我们在选定的设备上双击， 此时可以在设备上看到，我们的应用程序运行起来了。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"2 开发环境搭建","slug":"4_开发/2_开发环境搭建","date":"2017-01-24T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"4_开发/2_开发环境搭建/","link":"","permalink":"http://booktest.anddle.com/4_开发/2_开发环境搭建/","excerpt":"","text":"开发环境搭建开发安卓应用可以在Window系统 MacOS系统 Linux系统上进行。但并不是说打开一个写字板就可以了，它还需要编译器等开发工具的配合。所以在正式开发之前，需要搭建开发的环境，我们需要给开发平台（Window系统 MacOS系统 Linux系统）安装上： JDK（Java Development kit）：Java开发工具包，因为安卓使用java开发，而且安卓应用开发的其它部分工具也依赖于java开发环境，所以必须安装JDK； Android SDK（Android Development kit）：谷歌提供的安卓应用开发工具包。 Android Studio：谷歌提供的安卓开发环境。 不同的平台搭建开发环境的过程几乎相同。我将介绍如何在Windows系统 MacOS系统上进行开发环境的搭建。 安装JDKJDK可以通过官方网站下载。 下载时，请根据操作系统的种类和位数进行选择。 下载到本地后，双击安装包进行安装。 如果使用MacOS系统，可以安装XCode。XCode在安装过程中，已经完成了对JDK的安装。所以使用MacOS开发会显得非常的方便：只需要安装一个XCode，其他很多开发工具就都有了（其他程序的开发环境也是类似）。所以我强烈的推荐你，今后有了资金，一定要选Macbook。 验证JDK安装是否成功的方式，在不同平台下稍有不同。 Windows验证安装完成后， 通过Win+R启动Windows操作系统的运行面板； 在面板中输入cmd，启动命令行窗口； 在命令行窗口中，输入java -version; 如果此时能看到类似以下的内容，就说明JDK安装成功了。 123C:\\Users\\XXX&gt;java -versionjava version \"1.8.0_66\" Java(TM) SE Runtime Environment (build 1.8.0_66-b18)Java HotSpot(TM) 64-Bit Server VM (build 25.66-b18, mixed mode) MacOS验证安装完成后， 启动terminal命令行窗口； 在窗口中输入java -version； 如果此时能看到类似以下的内容，就说明JDK安装成功了。1234GymdeMacBook-Pro-7:~ Gym$ java -versionjava version \"1.8.0_65\"Java(TM) SE Runtime Environment (build 1.8.0_65-b17)Java HotSpot(TM) 64-Bit Server VM (build 25.65-b01, mixed mode) 安装Android Studio感谢Google中文开发网站的上线，让我们可以很方便的下载到Android Studio，以及它集成的Android SDK了。 针对不同的平台，官方网站提供了不同的下载包， 平台 Android Studio 安装包 Windows android-studio-bundle-145.3537739-windows.exe MacOS android-studio-ide-145.3537739-mac.dmg Linux android-studio-ide-145.3537739-linux.zip 下载完成后，双击安装包进行安装。 注意： 整个安装过程在官网的安装指南上，有详细的介绍，大家可以移步此处； 在Windows系统上搭建开发环境更加方便，谷歌将Android SDK和Android Studio打包在一起提供我们下载； 安装Android SDK从现在开始各个平台下的Android Studio操作都几乎完全一样了。 对于Windows系统，因为安装包已经集成了Android SDK，所以不用再去单独下载了。对于没有集成Android SDK的Android Studio还有后续的工作要做。 启动Android Studio之后，会提示我们安装Android SDK。 也可以通过Android Studio的设置功能，启动设置选项，切换到Android SDK选项卡，将列出当前已经安装或者可以安装的Android SDK组件， 选择Launch Standalone SDK Manager，启动SDK manager， 勾选上， Tools中的Android SDK Tools Android SDK Platform-tools和Android SDK Build-tools最新版本； Android X.X.X中的SDK和参考源码，例如，Android 7.1.1的SDK Platform（必选），Sources for Android SDK（可选，便于查看SDK中的源码）； Extras中的Android Support Repository，其他的可以不选； 如果是Windows系统，为了避免电脑不能识别连接上的安卓设备，可以多勾选一个USB driver。 选择Install packages之后，SDK Manager将自动下载。完成之后， 整个Android SDK也就安装完毕了。 安卓的中文开发官网上，有更多的详细的介绍。遇到任何问题，都可以来这里查看官方的文档。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"1 开发产品","slug":"4_开发/1_开发产品","date":"2017-01-23T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"4_开发/1_开发产品/","link":"","permalink":"http://booktest.anddle.com/4_开发/1_开发产品/","excerpt":"","text":"开发产品当开发者拿到设计师提供的原型（静态或者动态）和资源后，也并不是就可以开始写代码了。 开发阶段通常还会包含以下几个部分： 1功能验证 -&gt; 设计文档 -&gt; 编写代码 -&gt; 测试 -&gt; 产品发布 -&gt; 产品升级 在整个开发的过程期间，还需要对各种文档、代码、资源进行管理，引入版本控制的概念。 功能验证如果产品的功能很复杂，开发者在正式开始编码前，还得做一番功能的验证。也就是， 在创意阶段确定功能点的那些验证功能可行性的工作； 设计师设计的界面逻辑合理性验证； 设计师的设计要落地，并不是天马行空，而是要和开发者的实际情况匹配才行。 开发并不是只有编码的工作，这是一个系统的工程，还包括了各种写作设计文档和代码的管理技巧。 设计文档写文档也是开发者重要的工作，你不能保证将来永远自己来维护自己写的代码，所以要把自己的设计思路用文字、图表的形式记录下来，便于后继者能够理解。 根据开发阶段的不同，产出文档的内容也不同；而且不同的公司或团队，也有不同的要求。撰写开发文档，是一个很具有弹性的工作，如果身在一个以快为核心价值的小团队（2-3个人），也许就不会把大把的时间花在这上面；如果是一个拥有几十人的大团体，或者是以严谨闻名的日本开发者，一定会把程序设计的方方面面都体现到设计文档当中。 国内的大多数程序员都是思维超前的物种，不大会拘泥于每天写文档这样“小节”，对文档的态度大都是能拖就拖，能不写就不写。程序员的精力太宝贵了，总希望把它们投入到更多的新功能的开发当中。所以写文档成了程序员们最头痛的事情了–不是不会，而是没有兴趣。 要解决这个问题，除了强制要求，似乎也没有特别有效的办法:( 在开发我们的天气预报时，我简化了文档方面的要求，没有使用专业的设计文档。大家可以将本文就作为天气预报的设计文档-因为只要把这篇文档从头到尾看一遍，你就一定能设计出这个应用-这也正是各种设计文档存在的终极意义。 版本控制和写小说一样，内容可能会经历反复的修改，一段代码加入之前，程序运行的很好，但是加入之后却发生了意外，不得不回到修改前的状态。退回到以前的状态，通常会非常的繁琐，程序员必须的记住每一个修改的细节。 如果采用了版本控制的技术，退回到之前的修改将是一件非常容易的事情，只需要一个按键即可。除了代码、任何文档的修改都可以用版本控制软件来管理。例如我现在正在敲下这篇文档以及这一系列文档将组合成的书，都是在版本控制软件-Git的帮助下完成了。 其他测试、产品发布、升级看起来比较简单，但都是一门可以很深入的学问，我们将为它们开辟单独的大章节来讲述。 进行安卓软件开发我们还需要准备3样东西， 一台安装了Windows系统或者MacOS系统的电脑（Linux系统也可以，不过我在后面的章节中不会单独的讲如何搭建Linux系统下的开发环境）； 一台安卓5.0及其以上的手机设备：我们这里的安卓开发是基于Material Design的，而它是在安卓5.0的系统上推出的。所以对安卓系统提出了版本上的要求。目前市场上绝大多数的主流手机已经过渡到了安卓5.0之上了。如果你的设备还很古老，是不是可以考虑稍微与时俱进一点了呢？ 我将使用一台标准的安卓设备Google Nexus 5作为调试用的真机。 开发程序的时候也可以使用模拟器来代替真机。不过我到建议能用真机是最合适的，运行速度快、对电脑的配置也没有要求，更能够省去使用模拟器可能遇到的各种状况。 一根连接手机与开发电脑的数据线：数据线通常使用的是micro USB接口，它几乎成了安卓手机的标配。不过越来越多的手机开始引入了USB type-C接口了。这根数据线都不需要单独去购买。买手机的时候，商家会把这样的数据线作为标配提供的。","categories":[{"name":"第4章-开发","slug":"第4章-开发","permalink":"http://booktest.anddle.com/categories/第4章-开发/"}],"tags":[]},{"title":"10 资源的创建","slug":"3_产品原型/10_资源的创建","date":"2017-01-22T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/10_资源的创建/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/10_资源的创建/","excerpt":"","text":"资源的创建界面原型已经设计完成了。不过离最后交付给开发人员开发还差一步：产品中使用的图片还没有准备好呢？ 设计师除了产品原型还要交付哪些资源呢？开发者最关心的资源就是应用中会使用到的各种图标资源和配色方案。 在天气预报应用当中，我们已经确定好了界面的主要颜色， 颜色项目 颜色名称 颜色RGB值 Primary Color Indigo 500 #3F51B5 Primary Dark Color Indigo 700 #303F9F Accent Color Amber 500 #FFC107 现在就剩下各种图标了。这些图标包括了， 系统图标：显示更多信息时使用到的， 天气图标：包括使用到的小图标， 使用到的大图标， 应用图标：应用的主图标，放在启动界面使用的图标， 图标的尺寸不同使用场景的图标，尺寸是不同，前面的章节中我们已经讲述了系统图标 应用图标的标准尺寸。 根据屏幕像素密度的不同，需要设计对应大小的图标。这样一来，就能够确保在特定类型的密度屏幕上，图标能够显示的清晰。 像素密度类型 像素密度大小 与Baseline比值 mdpi 160 1 hdpi 240 1.5 xhdpi 320 2 xxhpi 480 3 xxxhpi 640 4 安卓使用dpi为160的数值作为一个基准－－baseline。 为了达到最优秀的显示效果，我们最理想的情况下是为每个不同的屏幕类型设计对应的图标。不过实际情况中却并不一定需要对应每个尺寸，因为 如果涉及的图标很多，各种类型的图标都做全部的配套设计一定会增加应用的体积； 假如缺少某个屏幕类型（例如mdpi）的图标a时，系统会去寻找a对应的高分辨率图标A，把A转化成合适的尺寸（a与A都是同一个图标的不同尺寸版本，a尺寸小，A尺寸大）。这里唯一的代价是：在使用图标时，系统需要自动做额外的尺寸转化； 系统图标系统图标的大小是24dp*24dp，对于mdpi的屏幕，我们就需要截取24px*24px大小的图标。 Sketch导出如果使用Sketch开发出了静态原型，那么从里面抓取系统图标就非常的方便了， 点击工具栏上的insert -&gt; S（或者按快捷键S）， 用小刀在要截取图标的位置切片，并将切出的片子，重新命名成ic_wind_level, 可以看到右上方的尺寸栏显示的是24/*24的大小，设置区域下方的截取效果图也呈现了出来。 接下来就是导出图片了， 选中ic_wind_level，点击Export旁的按钮，以此添加1x 2x 3x 1.5x 4x，给要导出的图片设置导出后的放大倍率。1x表示1:1导出，2x表示放大2倍导出， 导出的格式都设置成PNG格式的图片。这种图片是安卓系统标准支持的图片格式，能够携带透明的信息。 不要勾选背景颜色，让整个图片除了图案以外，都呈透明的状态；选择Export ic_wind_level， 导出结果如下， 像素密度类型 与Baseline比值 实际像素 mdpi 1 24px hdpi 1.5 36px xhdpi 2 48px xxhpi 3 72px xxxhpi 4 96px 其他图标的导出和产生这个图标的方式类似。 第三方工具导出如果不使用Sketch也可以通过其他工具生成图标。例如Android Studio Asset的Generic icons功能。 通过IMAGE方式，将事先准备好的风力.svg矢量图，加载到工具当中； Size选择20dp，Padding选择2dp，这样最后的图标就是24pd*24dp的了； Color选择成黑色，透明度为54%； 点击DOWNLOAD .ZIP; 下载解压后，得到了对应的图标资源， 其他图标的产生和产生这个图标的方式类似。 天气图标天气图标的导出与系统图标的导出几乎完全一样，只是尺寸和颜色稍有不同。 在导出的时候要注意天气图标有两种不同的大小，一种使用到Weather details上面，显示大的天气图标；另一种使用到forcast当中，显示小的天气图标。 图标类型 宽度 高度 大图标 120dp 100dp 小图标 30dp 30dp 两种图标都可以通过Sketch切图得到，也可以通过Android Asset Studio来生成。 应用图标应用图标也可以通过Sketch创建，不过我这里就简化了这方面的设计，直接使用Android Asset Studio的Launcher icons，创建应用图标， 通过IMAGE方式，将事先准备好的应用启动图标.svg矢量图，加载到工具当中； Padding选择45%，调整到合适的比例就行； Color选择成白色，透明度为100%； Shape选择成SQUARE正方形； Background选择成Primary Color-#3F51B5 点击DOWNLOAD .ZIP; 下载解压后，得到了对应的图标资源， 至此，图片资源的导出就完成了。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"9 Origami动态原型设计","slug":"3_产品原型/9_Origami动态原型设计","date":"2017-01-21T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/9_Origami动态原型设计/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/9_Origami动态原型设计/","excerpt":"","text":"动态原型设计动态的可交互原型产品，是产品经理和界面设计师向开发人员阐释自己设计的最高效工具。 开发者不需要猜测设计师要什么样的效果，照着原型产品做就好了。 很多创业团队也发现了产品人的这个刚需，做出了诸如Principle、Axure这类著名的原型设计产品。 Facebook似乎也深谙此道，专门为安卓和iOS系统开发很有针对性的交互原型设计工具-Origami Studio。 这是一个免费的工具，而且也能和Sketch互通，所以我选择了它来向大家讲解互动原型的设计。 界面介绍启动Origami Studio后，可以看到类似如下界面， 悬浮在外的区域是虚拟手机屏幕。用户可以通过点击、拖动来模拟各种屏幕操作; 底部的暗色区域是工作区域。用来设置用户操作屏幕后，界面元素的各种响应方式； 右边的亮色区域是界面组件区域。展示了组成界面的各个元素，里面的布局方式，通过虚拟屏幕实时展示了出来； 点击虚拟屏幕右上方的摄像机按钮，可以将屏幕上的内容录制下来， 创建屏幕界面对于新创建的项目，整个工程都是空的， 我们可以通过菜单栏的+，为界面添加各种组件， 也可以直接将Sketch中的图形，通过复制粘贴的方式，直接添加到组件区域。 通过Phone -&gt; Nexus 5将虚拟设备的屏幕，设置成Nexus 5- 安卓设备； 将组件区域中Color Fill的背景色修改成白色， 然后，打开上一章节中Sketch设计的静态高保真原型， 选中Weather页面的展开画板，使用cmd + c（复制）； 切换到Origami Studio，cmd + v（粘贴）； 整个界面就导入完成了， 所以我之前说，使用Sketch进行界面设计可以事半功倍，它与Origami Studio配合的非常好。 设置滑动区域当用户滑动Content区域的时候，该区域要能够跟随手指，向上滑动。这里就有2个要点， 滑动Content区域：要能够感知到这个区域被滑动； Content区域跟随滑动：滑动的位移能够作为输入，实时的影响Content区域的位置； 感知交互组件旁边有个touch按钮，点击后会出现该组件可能会接收到的各种触控方式。在本例中，我们是需要感知Content组件垂直方向上的滑动，所以选择ScrollY， 此时，工作区域和虚拟屏幕都发生了变化， Content区域的位置发生了变化，被“顶”到了整个屏幕的最上面。这是为什么呢？因为Content区域的Y坐标被修改成了0。 在紫色的Scroll框图中，Content Layer被指定成了Content，说明需要关注Content的滑动。Y坐标的变化将被输出到蓝色框图代表的Content区域，修改它的Y坐标。 因此，当框图被这样组合之后，我们没有触控Content区域，Content的Y轴就没有滑动，因此输出就为0。0作为Content区域的新位置，就将其顶到了屏幕的最上方。 因此，我这里可以给出一个小技巧来避免这种错误的置顶效果， 给Content添加一个壳-Group（+ -&gt; group），将Content包裹在里面(通过拖动Content到Group中实现)； Group的尺寸从屏幕的顶端开始计算，占据整个屏幕； 然后再给Group添加响应， 可以看到，现在虚拟屏幕上的界面就没有变形了。在屏幕上进行拖动，Content区域就可以随着Y轴的偏移，而实时的修改自己的Y坐标，达到互动的效果， Content滑动的过程中，Weather detail，也需要随着向上滑动，并隐藏起来。 有了上面处理Content的经验，我们就知道需要如何处理Weather detail的滑动了。 给Weather detail添加一个壳-Group，将Weather detail包裹在里面； Group的尺寸从屏幕的顶端开始计算，占据整个屏幕； 鼠标按住紫色框图Y字符的位置，拖住不放，连接到组件区域上方的Y坐标处， 工作区域就会自动添加紫色框图到新Group的连接， 注意：这种拖拽端点到属性值的方法贯穿了使用Origami Studio的各个地方，是非常核心的操作方式。 此时滑动界面的时候，Weather detail也会跟着滑动了， 这时可以看到，状态栏被挡住了。解决的办法很简单，只要在组件区域，把Statusbar拖动到最上面的位置就可以了， 标题的变化现在开始加入标题-成都的变化。 把成都从Weather detail中剥离出来，便于全局的控制，进行如下设置， 在界面滑动的过程中，字体的大小和X Y坐标都要发生变化，说明需要找到内容区域Y轴滑动时的比例，然后让成都元素的对应属性发生变化。 滑动变化有自己的百分比：（当前值-原始值／变化范围）* 100% = 变化的百分比 原始值：0 变化范围：-245（245是Weather detail的高度） 成都文字的属性变化范围是： 属性 属性起始值 X坐标 24 -&gt; 16 Y坐标 244 -&gt; 38 字体大小 34 -&gt; 20 在Origami Studio中确定变化范围，需要使用Progress patch（到底什么是patch，会在后面介绍）。 在工作区域双击，弹出patch选择框，找到Progress， 修改Progress patch的Start value为0，End value为-245， 开始修改成都文字的Y坐标。 在Progress path之后，添加一个Transition patch； Start为244，End为38； 将Transition patch的输出，通过拖拽的方式，连线到成都元素的Y坐标值的位置； 开始修改成都文字的X坐标。1. 在Progress path之后，添加一个Transition patch；2. Start为24，End为16；3. 将Transition patch的输出，通过拖拽的方式，连线到成都元素的X坐标值的位置； 开始修改成都文字的字体大小。 在Progress path之后，添加一个Transition patch； Start为34，End为20； 将Transition patch的输出，通过拖拽的方式，连线到成都元素字体大小的位置； 至此，我们可以看到滑动时，标题变化的雏形了， 滑动的范围上下滑动时，内容是收到了局限的，只能在一定区域内滑动。所以要给目前的设计增加一个滑动限制。 添加一个叫做Clip patch过滤器； 将它允许输出的最小值Min设置成-245（也就是Weather detail的高度）；将允许输出的最大值Max设置成0； 修改框图的连接方式如下， 滑动的保持现在滑动虚拟屏幕的时候会发现，当松手之后，原来滑动到的位置会自动还原，但实际上我们希望它能够保持当前的状态。 将Content所在的Group向下移，放到Weather detail所属的Group的下面； 修改该Group的大小为1000； 至此，动画的效果就基本完成了。 尾巴这里留下了一个小尾巴：滑动的过程中，状态栏的颜色也是需要变化的，从#3F51B5逐渐变化到#303F9F。 经过前面的实践，我想大家应该已经知道了实现的要点，那就开始自己尝试着做做吧。 提示：通过Color to HSL patch Transition patch与HSL Color patch的配合，来修改状态栏背景元素的颜色属性。 整个工程的源文件，我放到了这里，供大家参考。 回顾总结通过具体的案例，我们初步了解了Origami Studio的用法，对实现动画的方式也有了概念。 一切的动画效果都是通过下面几个步骤来实现的， 感知触发动画的事件，点击、滑动等等； 把触发事件后产生的数值，交给一个个串联起来的patch进行处理，获得新的数值； 利用新的数值来修改某个界面元素的属性，比如文字的大小，文字的位置，文字的透明度等等； 知道了这样的套路，以后遇到其他动画就可以依葫芦画瓢来操作了。 至于什么是patch，我相信一步步做到这里，也都可以心领神会了吧。 另外，处理虚拟屏幕，Origami Studio产生都可交互原型，也能在手机设备上运行，前提是在设备上按照对应的应用Origami live。希望进一步了解的同学，请移步这里，有更为详尽的信息提供给你。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"8 静态原型的Appbar折叠","slug":"3_产品原型/8_静态原型的Appbar折叠","date":"2017-01-20T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/8_静态原型的Appbar折叠/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/8_静态原型的Appbar折叠/","excerpt":"","text":"静态原型的hexAppbar折叠接下来，我们开始设计Appbar被滑动收缩以后的界面效果。 可以看到，这个效果图绝大部分和展开时的效果图时一样的。 所以我们可以将整个画板修改一个名字为-展开，并复制出一个新的画板命名为折叠，修改一下其中的元素就好了。 使用Symbol这样做完全没有问题，但是可能会给以后内容的修改留下一个隐患：假如我要把风力从3级修改为5级，除了要修改展开画板，还要修改折叠画板，要修改两个地方。 不过假如我将More info和Forcast做成了Symbol，那么只需要修改一处，两个画板中的内容就都可以变化了。 将More info Forcast和gap，组合成一个组件Content， 然后，使用转换Symbol的功能， 之后，在Symbols页面，就能看到Content的内容了， 之后，只要修改这个Symbol中的任何内容，都可以同步的反应到使用了它的界面之上。 创建折叠界面在Weather页面，复制展开，改名为折叠， 修改Appbar中的内容， 移除Weather detail，将Content的位置上挪，并调整画板的高度至合适位置， 显示Toolbar中的位置-成都， 修改状态栏的背景颜色为Primary Dark Color：#303F9F， 至此，使用Sketch进行界面设计的工作就全部完成了。 文中使用到的完整的Sketch项目工程文件，可以在这里下载到。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"7 静态原型的更多天气信息","slug":"3_产品原型/7_静态原型的更多天气信息","date":"2017-01-19T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/7_静态原型的更多天气信息/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/7_静态原型的更多天气信息/","excerpt":"","text":"静态原型的更多天气信息天气的更多信息，是通过列表的形式展现的。 参数设计 列表项的高度在Material Design中，被定义成了48dp；并且整个list的顶部还有8dp的边距。 列表项由3部分组成， 图标： 项目 数值 大小 24dp 左边距 16dp 位置 垂直居中 颜色 #000000 透明度 54% 项目名称： 项目 数值 字体 Noto 字形 Regular 大小 16sp 颜色 #000000 透明度 87% 左边距 72dp 位置 垂直居中 项目取值（参考）： 项目 数值 字体 Noto 字形 Regular 大小 14sp 颜色 #000000 透明度 54% 右边距 16dp 位置 垂直居中 注意：以上的数据都在Material Design的文档List当中有明确的定义。 添加列表项区域创建一个360dp*48dp的矩形区域-row bound，作为第一条数据项使用的空间， 注意：list的顶部8dp边距，这里还没有加上。因为我准备在添加完成所有的列表项后，再做整体的移动。 添加图标系统图标的尺寸是24dp的正方形，但是最外一圈还要有2dp的边距，所以真正的图标内容是局限在一个20dp*20dp的区域内的。 首先， 创建一个24dp*24dp的矩形-icon bound； 放到距row bound左边距16dp的位置； 让它垂直居中； 然后， 从事先准备好的资源文件中，找到风力.svg，拖入到Sketch的工作区域；调整图片大小为20dp*20dp; 颜色设置成#000000，透明度54%； 将其放置于icon bound的中心位置； 删除icon bound的背景色和边线； 添加项目名称在row bound的区域内， 添加风力文字； 设置左边距为72dp； 字体为Noto，大小为16sp，字形是Regular； 字体颜色设置成#000000，透明度为87%； 添加项目取值在row bound的区域内， 添加3级文字； 设置右边距为16dp； 字体为Noto，大小为14sp，字形是Regular； 字体颜色设置成#000000，透明度为54%； 列表项组合将风力文字、风力图标、3级、row bound、icon bound组合成一个新的组件风力， 最后把row bound的背景色和边线移除掉， 添加多个列表项复制粘贴第一个列表项，把剩余的项目以此添加到画板当中， 之后将它们组合成一个组件-More info， 最后再整体把More info向下移动8dp，使之符合List的设计规范， 这里有个技巧：在制作列表的时候，会发现数据已经超出了手机屏幕的高度，这时候，可以把Mobile Portrait的高度扩展到足以容纳的尺寸， 至此，整个主要界面的设计就完成了。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"6 静态原型的天气详情","slug":"3_产品原型/6_静态原型的天气详情","date":"2017-01-18T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/6_静态原型的天气详情/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/6_静态原型的天气详情/","excerpt":"","text":"静态原型的天气预报未来5天的天气预报，可以看成由5个类似的天气模块构成，只要完成一个，其他几个就可以通过复制+修改内容实现改变。 首先来明确一下各个组件的尺寸和参数， 整个区域的大小，我设定成360dp*100dp； 左右边距设置成16dp； 这样一来，每日的天气模块就是（360-16-16）/ 5 = 65.6dp，我将它们设定成65dp宽； 天气的图标的大小设定成30dp的正方形区域（注意，这些图标不算是系统图标，所以它的尺寸不需要参考设计成24dp的系统图标）； 日期的文字，参考Body 2的文字类型： 温度范围的文字，参考Caption的文字类型： 创建预报区域接下来，我们开始创建预报区域。划定一个360dp*100dp的区域， 添加一个预报模块添加一个65dp*100dp的背景限制区域-bound，以后每个预报模块的内容都要放到这个区域当中。这也是一个很有用的技巧。 从事先准备好的资源文件夹中，添加雪，并使用Primary Color-#3F51B5给它上色， 将预测温度和温度范围添加进去，并用Body 2和Caption分别设定它们的属性， 将雪``bound``明天``18℃～21℃组合起来，形成-明天；并调整它们的位置，使之居中， 添加第二个预报模块复制明天组件，产生第二个预报模块，修改第二个模块的名称和内容为星期六， 修改雪的图标成晴。 将资源晴从文件中拖到工作区域； 参考之前的方式调整图标的大小、位置和颜色； 将原来的图标雪，删除； 添加三个预报模块之后，重复之前的动作，完成星期日 星期一 星期二的内容创建， 位置排列将明天 星期六 星期日 星期一 星期二与forcast_bg组合到一起，形成Forcast， 因为要给左右两端留下16dp的内容，明天 星期六 星期日 星期一 星期二没有办法水平瓜分forcast_bg占据的空间。所以这里我就使用了一个小把戏：把forcast_bg的宽度缩短32dp，变成328dp，并将它水平居中， 再调整明天和星期二的水平位置，使之刚好位于forcast_bg区域之内， 再选中明天 星期六 星期日 星期一 星期二与forcast_bg，使用水平分配空间的功能，让预报模块平均占用空间， 最后，出去背景颜色，预报区域就全部完成了， 添加隔断为了界面分层，逻辑清楚，我在预报区域的下面，设计了一个360dp*10dp的隔离带，颜色为：#BDBDBD，","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"5 静态原型的Appbar","slug":"3_产品原型/5_静态原型的Appbar","date":"2017-01-17T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/5_静态原型的Appbar/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/5_静态原型的Appbar/","excerpt":"","text":"静态原型的Appbar我们设计的Appbar包括了两个部分，一个是toolbar，另一个就是flexible space-显示当日天气的详细信息， Toolbar参数确定添加Toolbar很简单，首先找到Material Design中对Appbar的描述可以知道， 这是一个高度为56dp的矩形区域； 当Appbar收缩时，应用的名字会显示出来， 注意：这里显示的是中文-Dense类型的文字，所以文字的大小比英文要大1sp。 添加Toolbar先添加区域， 选择Insert -&gt; Shape -&gt; Rectangle(或者快捷按键R)； 在期望的位置，拖动出一个56px*360px的矩形框；拖动的过程中，矩形尺寸会动态的显示出来； 此时画板上已经多出了一个叫做Rectangle的形状。 假如尺寸有偏差也没有关系，可以通过修改属性区域的高宽数值，进行精确的修改 修改背景颜色为Primary Color：#3F51B5， 接下来添加应用名称：这里要显示的并不是应用的真实名称，而是天气预报的位置， 选择Insert -&gt; Text(或者快捷按键T)； 在Toolbar的大致位置进行点击，写下位置名称-成都；此时画板上多出了Text组件； 修改新组件的属性为， 选中Rectangle和成都组件，使用cmd + G，将其组合成Toolbar 再来进行标题位置的设置， 选择Toolbar下的所有组件，点击垂直对齐的按钮， 标题的左边距是16dp，选中成都，同时按下alt按键，可以看到成都上下左右的边距大小，使用方向键调整左边距的大小即可， 因为此时并不需要显示位置信息，所以要点击成都组件旁边的眼睛按钮，把内容隐藏起来。 使用alt查看组件的边距是一个常用的技巧，查看的同时，如果移动鼠标到不同的区域，就能看到组件相对于不同区域的边距数值，这让我们在排版的时候非常的方便。 至此，Toolbar的设置就完成了。 天气详情区域参数设定天气详情区域由三个部分组成， 天气图标； 当前温度，当日温度范围； 位置信息； 整体设计上讲，天气详情区域、Toolbar和状态栏都是整体的蓝色，占据整个屏幕空间的一半。因此这里将天气详情区域的高度，设计成245dp，它内部的元素都布局在360dp*245dp的区域范围内。 图标和温度的设计是比较自由的，只要设计师觉得美观就好了。我将它们放在两个150dp*100dp的矩形当中，让它们的左、右、上边距都成为24dp。 当前温度，采用Display 3的类型， 项目 数值 字体 Noto 字形 Regular 大小 56sp 颜色 #FFFFFF 透明度 70% 当日温度范围，采用Headline的类型， 项目 数值 字体 Noto 字形 Regular 大小 24sp 颜色 #FFFFFF 透明度 100% 位置信息，采用Display 1的类型， 项目 数值 字体 Noto 字形 Regular 大小 34sp 颜色 #FFFFFF 透明度 100% 左边距 24dp 下边距 24dp 注意：Noto字体和Roboto字体对于English-like是兼容的，所以当表示数字、英文字母的时候，两者都可以使用。 添加天气详情根据之前的规划，划出360px*245px的矩形区域，背景色修改成Primary Color：#3F51B5。默认情况下创建的矩形会有border，我们将它移出， 创建两个150dp*100dp的矩形，准备用它们分别装入天气图标和温度信息; 将新创建的矩形和bg进行组合； 调整两者顶部和左右的边距为24dp， 添加天气图标引入天气图标， 打开之前准备好的资源文件夹，把晴间多云的图标-阴晴拖入工作区域，尺寸设置成120dp*100dp； 将刚引入的阴晴与之前的weather icon bg组合成一个新的组件-Weather icon，并将阴晴水平居中放置， 展开阴晴，修改其颜色成Accent Color：#FFC107， 移除weather icon bg的背景颜色， 在对图标进行居中设置的时候，需要选中阴晴和weather icon bg，使用水平居中对齐功能。weather icon bg在这里充当了被对齐的参照物，在使用Sketch设计的时候，经常需要添加一个这样的辅助设计元素。 添加温度信息使用快捷按键T，在相应的位置，添加两个文字输入区域，写上对应的内容，并设置好对应的字体属性。 对组件结构进行调整， 对文字进行水平居中的排列，并移除背景的颜色， 添加位置在适当的位置，添加一个Text组件，写入成都，做好设置， 注意，它的左边距和下边距都是24dp。 至此，整个Appbar的内容就添加完毕了。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"4 静态原型的状态栏","slug":"3_产品原型/4_静态原型的状态栏","date":"2017-01-16T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/4_静态原型的状态栏/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/4_静态原型的状态栏/","excerpt":"","text":"静态原型的状态栏状态栏Symbol状态栏似乎很复杂，有wifi信号、手机信号、时间、电量等信息，幸好Sketch原生就自带的现成组件，你可以直接拿过来就用了。当然，你也可以自己一个一个去画，不过既然有了现成的轮子，又何必重复劳动呢。 菜单栏中选择File -&gt; New From Template，在弹出的菜单中选择Material Design。此时会创建一个新的工程文件。 与之前空的工程文件不同的是，这里面已经有了两个现成的page，里面的内容就是Material Design会使用到的各种现成的组件。 选择Material Design Symbol -&gt; Material/Android/Status bar 360dp black，这就是一个现成的可用的状态栏。这样的组件叫做symbol，它是有多个图形组合后形成的一个通用符号。Symbol可以被不同的page、项目共享使用。 以后只要看到这个图案，就知道这是一个symbol了， 我们也可以创建自己的symbol，不过这个地方还不会用到。随着设计开发的深入，在这个章节的后半部分，我们会进行详细的介绍。 使用状态栏Symbol使用鼠标右键 + Copy（或者cmd + c）之后，将它粘贴（鼠标右键 + Paste Over或者cmd + v）到我们之前的weather page之中， 如果状态栏粘贴之后，并没有对齐画板的边缘，手动将它移动，对齐就可以了。 此时可以看到， Pages下面自动多出了一个叫做symbols的页面，它里面放的就是我们刚引进的symbol。 这时的statusbar还是一个独立的部分，并没有隶属于Mobile Portrait画板之下，两者还是平级的关系。 调整状态栏Symbol接下来我们就开始调整statusbar与Mobile Portrait之间的隶属关系。 将状态栏展开，选中里面的内容； 将各个组件拖入到Mobile Portrait之下； 删除没有内容的状态栏symbol； 将刚拖入的组件使用工具栏上的Group功能组合起来，并将组合后的组件更名为Statusbar； 选中状态栏，我们可以看到状态栏的尺寸是：24px*360px，刚好是前面讲过的状态栏应该的高度。 修改背景色将状态栏的背景颜色修改成之前设定的Primary Color：#3F51B5，","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"3 Sketch静态原型设计","slug":"3_产品原型/3_Sketch静态原型设计","date":"2017-01-15T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/3_Sketch静态原型设计/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/3_Sketch静态原型设计/","excerpt":"","text":"Sketch静态原型设计对于静态原型的设计，我们使用Sketch。 启动Sketch后，我们将看到类似如下的界面， 工具栏它的顶部是工具栏， 可以通过菜单栏View -&gt; Customize Toolbar...来自定义工具栏。在弹出的窗口中，将下方的图标拖拽到上方的工具栏中就可以了。 导航栏左边是导航栏，用来展示这个项目拥有的page和page中包含的详细内容。 page是一张张单独页面， 每个页面上可以放多个手机屏幕的画板：展开、折叠、图标等等； 每个page中的画板都进一步的在导航栏的下半区域展示出来：展开、折叠、图标等等； 多个page被归类到了pages的下面：Weather、 Symbols等等； 我们设计的程序界面，就是某个page， 工作区域工作区域显示的是page的详细内容。我们设计的程序界面具体样子，就是通过工作区域展现出来的。 属性设置区域属性设置区域用来设定某个选定图形的属性，例如它的大小、透明度、文字内容、字体颜色等等。 添加设备画板在新建的 Sketch项目中，双击导航栏的page1，把页面的名字改成一个有意义的名字-Weathear， 通过工具栏的Insert -&gt; Artboard，调出画板，选择Material Design下的Mobile Portrait， 通过右侧的属性设置区域，可以看到这个画板的大小为360px*640px，正好是一个mdpi的安卓设备屏幕尺寸。所以我们在这样的尺寸上做设计，能够很容易的顾及到其他像素密度的设备。 可以看到Sketch为多种界面提供了默认的尺寸，iphone的，安卓设备的，网页的，MacOS应用的，可以说是应有尽有。这也说明Sketch就是为了这些产品而设计出来的。 除了使用菜单栏调出画板，你也可以使用快捷方式：A。这也是操作Sketch必须记住的快捷方式之一。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"2 前期准备","slug":"3_产品原型/2_前期准备","date":"2017-01-14T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/2_前期准备/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/2_前期准备/","excerpt":"","text":"前期准备设计师首先在头脑中、草稿中勾勒出静态效果图， 之后就需要收集制作时需要的各种素材、确定界面的配色方案。 收集素材界面中需要使用各种天气图标：晴天、雨天、大雾、下雪、下雨、多云等等；还有天气信息中的风力、风向等等。 我们可以使用Sketch工具进行完全的从无到有的自由创作，也可以适用现有的素材，减少设计的工作量。 这里并不打算讲如何画出一个完美的图形，我想作为一名设计师，这点基本的艺术功底应该还是有的。因此我决定去之前介绍过的资源池-iconfont网站寻找合适的图标。 输入各种图标的关键字，就能看到各种图标，例如多云， 点击希望的图标，准备下载， 可以选择图标的颜色、尺寸和下载的图标格式。这里我们选择SVG下载，也就是下载矢量图标（矢量图我们将在后一小节相信介绍）。至于颜色和尺寸就都无所谓了，因为后面我们使用的时候都会做出调整的。 以此方法，我们接着下载完成所有设计中需要使用到的图标，它们包括：风力、风向、湿度、空气质量、运动、紫外线、晴天、雨天、多云、多云间晴、雾、雪。 如果你的时间很宝贵不想把精力放到挨个下载上，那么我这里为你提供了打包好的所有可用素材，快去下载吧。 矢量图矢量图是设计当中经常使用到的图片类型。当设计师放大图片的时候，矢量图会跟着放大，但是图形的线条并不会变的模糊出现锯齿的形状。所以这是设计师的最爱。因此在前面下载矢量图标的时候，我说不用在意图标的尺寸，就是这个道理。 矢量图通常用在手动制图当中，占用的磁盘空间很小，它其实就是一个对笔划进行描述的文本文件，用文本编辑器打开的话，可以看到他的文本内容，例如， 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" t=\"1484009234652\" class=\"icon\" style=\"\" viewBox=\"0 0 1204 1024\" version=\"1.1\" p-id=\"2794\" width=\"18.8125\" height=\"16\"&gt; &lt;defs&gt; &lt;style type=\"text/css\"/&gt; &lt;/defs&gt; &lt;path d=\"M882.526316 286.796992q-17.323308 17.323308-42.345865 17.323308t-42.345865-17.323308q-18.285714-18.285714-18.285714-42.827068t18.285714-42.827068l42.345865-42.345865q17.323308-17.323308 42.345865-17.323308t42.345865 17.323308q18.285714 17.323308 18.285714 42.345865t-18.285714 43.308271zM250.225564 611.12782q-3.849624-16.360902-6.255639-33.684211t-2.406015-35.609023q0-61.593985 23.578947-116.451128t64.481203-95.278195 95.278195-64\"/&gt;&lt;/svg&gt; 这就是矢量图的描述语言。在安卓应用的设计当中，我们也有机会与矢量图进一步的打交道。 安卓应用的图形资源是支持开发者直接使用矢量图形的，安卓5.0开始的tint功能就经常需要和矢量图配合着使用。 配色方案天气预报的整体配色，我决定从Google提供的Material Design调色板中进行选择。 天气预报讲的是天空的故事，提到天空，第一感觉就是蓝色，因此我决定将配色方案定调成Indigo 500，金色代表太阳，作为与之配合的Accent Color。 打开配色方案的工具网站material palette，选择对应的颜色， 我们就得到了下面对应的颜色值， 颜色项目 颜色名称 颜色RGB值 Primary Color Indigo 500 #3F51B5 Primary Dark Color Indigo 700 #303F9F Accent Color Amber 500 #FFC107 图中的Light Primary Color和Divider Color我们这里暂时用不到。 图中的Primary Text和Secondary Text 就是我们前面提到的文字颜色。亮色背景下，这里看到的颜色分别是#212121和#757575。准确的讲，它们应该是： 使用的场景 透明度 颜色 Primary text 87% #000000 Secondary text 54% #000000 假如背景是白色，那么这个透明度的黑色在去除了alpha值以后，就分别对应#212121和#757575了。 图标的颜色应该是： 颜色透明度 颜色 54% #000000","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"1 原型设计","slug":"3_产品原型/1_原型设计","date":"2017-01-13T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"3_产品原型/1_原型设计/","link":"","permalink":"http://booktest.anddle.com/3_产品原型/1_原型设计/","excerpt":"","text":"原型设计通过前面几个章节，我们已经掌握了安卓系统Material Design设计的大致原则。接下来，我们开始尝试将这些原则和方式运用到实际的项目当中。 效果图与交互原型产品原型的设计又可以分成两个阶段， 高保真效果图：这是产品的静态效果图，图纸上的设计效果与最后实际产品基本上是一模一样。产品中使用到的各种图标都可以从高保真效果图中截取出来使用（这里其实指的是使用sketch进行界面原型设计，它可以从效果图中提取图标素材）。 可以交互的原型产品：为了向产品的规划者（PM-产品经理）确认设计的正确性，同时向后继的开发人员展示正确的设计意图，设计师需要创建出一种能具有交互功能的原型产品。这种原型产品就像是一个已经开发完成了的最终产品，可以进行点击操作，具有互动性。 当然这毕竟只是一个“虚假”的产品，只是具备了展示的功能。 接着创意阶段的工作，需要我们将天气应用框线图的规划，变成一个像模像样的产品原型。设计师需要根据功能点，结合Material Design的设计里面，创造出一个让用户在视觉和交互上满意的产品。这种创造需要结合设计师的个人能力和经验。 我们的天气应用很简单，它简化了很多的功能，按照原型设计的两个阶段，可以将他们设计成下面这个样子， 高保真效果图： 可以交互的原型产品： 假如设计师设计的产品交互方式，很容易被开发者理解，那么动态交互原型也是可以不用设计的。不过，为了更加全面的展示设计的具体过程，我们这里会首先设计一套天气应用的高保真效果图。然后在此基础上，设计一套可以互动的产品原型。 这里我们的交互设计，参考了Material Design中Appbar可以上下滑动的效果， 设计工具设计高保真的效果图时，我们选择采用了MacOS上才能使用的Sketch。这是一款付费软件，大家可以在它的官网看到详细的信息。官网也提供了功能完善的试用版，作为初次的学习，大家可以通过它来练练手，实际的感受一下。 Sketch绝对是当今甚至未来几年应用程序界面设计行业中的主角，越来越多的设计师使用它来进行原型设计。 它的优点有， 体积小，运行时占用的资源少，性能高； 可以从设计的效果图中，直接导出开发时需要使用的图片； 导出的图片可以针对不同屏幕解析度的设备； 内置了安卓系统、iOS系统常用的公共组件（例如状态栏、常用控件、屏幕标准尺寸），可以拿来就用，不必全部重新设计； 设计可交互原型时，使用了FaceBook推出的Origami Studio，它可以把我们的静态效果图，转化成一个可以交互的原型。 使用它有两个原因， 这是一个免费的工具，有着强大的动画交互功能； Sketch制作的原型文件，可以直接导入到Origami Studio当中，减少设计的工作量； Sketch与Origami Studio一前一后互相配合，奠定了一个产品的牢固基石。","categories":[{"name":"第3章-产品原型","slug":"第3章-产品原型","permalink":"http://booktest.anddle.com/categories/第3章-产品原型/"}],"tags":[]},{"title":"9 界面模式","slug":"2_设计原理/9_界面模式","date":"2017-01-12T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/9_界面模式/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/9_界面模式/","excerpt":"","text":"界面模式Material Design的基础组件我们已经大体了解过了，现在我们看看Material Design在结合这些不同组件的过程中，有哪些套路，也就是有哪些常用的界面设计模式。了解了这些模式，可以帮助设计者们做出合乎开发者实现的方案。 设计的套路有很多，列表-list 分页-tab 网格-Grid 侧边栏 下拉刷新等等。这里只列出几个常见的，更多的方式请参考设计规范，以及其他各种优秀应用的精巧设计。 手机端屏幕大小是有限制的，好的设计会充分利用有限的空间，合理的向用户展示出更多的内容。 侧边栏侧边栏的设计最早是由国外的第三方开发者设计出来的，在用户中很受欢迎。于是后来被很多开发者采用。从安卓5.0开始，Google就推出了官方的实现方式，并作为一个典型的界面设计方案推荐给了大家。 带侧边栏布局， 更加具体的规范请参考这里。 底部导航栏通过类似底部导航栏的按钮，让界面切换显示更多的内容。 这中布局的方式也是苹果iOS的经典布局方式，不知道是Google的原创还是向苹果的致敬。 更加具体的规范请参考这里。 分页与底部导航栏类似，但是是放在界面上方。 更加具体的规范请参考这里。 动态变化我个人认为，界面元素和内容的动态变化，是整个Material Design的精髓。它带给了用户极好的视觉体验，是引导用户注意力的最好方法。 动态是通过过渡动画和滑动效果来实现的。 过渡动画在前面的章节已经介绍过了动画的内容，这里就不重复了。 这里就多看几个实际的例子吧。 滑动效果内容切换的时候，尽量的使用滑动的效果。 分页的滑动效果， AppBar的滑动效果，","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"8 设计的组件与常用模式","slug":"2_设计原理/8_设计的组件与常用模式","date":"2017-01-11T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/8_设计的组件与常用模式/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/8_设计的组件与常用模式/","excerpt":"","text":"组件与常用模式前面已经比较全面的介绍了Material Design相关的设计哲学、设计原理和方法论。这一章开始，我们将看看这些原理是如何在安卓系统当中得到实践的。 一个应用并不是完全从什么都没有来组建的，至少会有一匹一匹的砖嘛。而在界面设计当中，这些能够拿过来就使用的砖块就是控件。 例如，按钮 滑动条 列表等等，都是可以直接拿过来用的砖块。 Material Design最基础的体现，就是看看这些砖长成什么样，以及如何用Material Design的理念将这些砖组合起来，构建成应用的界面。 这样的砖块很多，Google在Material Design的规范中给出了详细的定义。 因此我不会一一列举，只是拿出其中一两个最为常见的、最为典型的砖块和大家讨论，看看规范该如何解读和使用。知道了这些典型砖块的实践方式以后，大家就能自己根据设计规范来查看资料了。 我这里选取了按钮 列表 应用栏 系统栏来详细的讨论。 按钮Material Design中有3类按钮： Floating action按钮：前面已经大致介绍过，它是一个圆形的按钮，悬浮在界面之上6dp的位置，当点击的时候，按钮会向上浮动（显示出更大的阴影），是界面中吸引用户的界面元素之一； Raised按钮：拥有背景颜色（Accent color）的按钮，点击时它在z轴的位置会向上变化； Flat按钮：按钮文字有颜色（Accent color）的按钮，点击时它在z轴的位置不会变化； Flat按钮Flat按钮常常用在toolbar、对话框以及需要与很多文字配合的地方。通常用来告诉用户“我能提供一些轻量级的功能，这些功能并不是我的特色，你知道我有就行”。 它的设计规范如下， 项目 数值 最小宽度 88dp 高度 36dp 边角弧度半径 2dp 左右margin 8dp 左右padding 8dp 字体大小 15sp 当使用亮色主题并按下按钮的时候，按钮的背景颜色是#999999，透明度为40%；当使用暗色主题并按下按钮的时候，按钮的背景颜色是#CCCCCC，透明度为25%； 当点击按钮的时候，会出现水波纹一样的动画， Raised按钮Raised按钮比Flat按钮能更加吸引用户的注意力。通常用来告诉用户“点击我以后，会启动我一个很重要的功能，你要特别注意”。 它的设计规范如下， 项目 数值 最小宽度 88dp 高度 36dp 默认z轴位置 2dp 按下时z轴位置 8dp 边角弧度半径 2dp 左右margin 0dp 左右padding 16dp 字体大小 15sp 当使用暗色主题时，背景的颜色如下， 按钮状态 数值 正常 调色板500类型的颜色 按下 调色板700类型的颜色 当点击按钮的时候，会出现水波纹一样的动画，之后按钮在Z轴的位置也会提升， FloatingAction按钮FloatAction按钮是界面当中最引人瞩目的按钮。它代表了这个界面能提供的最重要、最核心的功能。默认情况下它的尺寸是56dp，放在上方会小一点，是40dp。 按照中心位置会内嵌一个系统图标，系统图标的大小我们在图标的章节讲过，是24dp。 需要注意的是：并不是所有的界面一定要有个FloatAction按钮，它的存在完全是由应用的逻辑决定的。之所以我们看到那么多界面都有FloatAction按钮，是因为这是Material Design的典型特征，所以选择的很多例子都有它。如果某个界面确实需要FloatAction按钮，那么一个界面上也只能有一个，表明只有一个功能是最为重要的。 FloatAction按钮还有一些常用的使用模式： 当拥有FloatAction按钮的界面退出的时候，按钮要用动画的形式消失； 当拥有FloatAction按钮的界面显示的时候，按钮要用动画的形式出现； 当拥有FloatAction按钮的界面在内部进行切换的时候，按钮要有动态变化的效果； 按钮点击后可以，展示出更多菜单； 按钮变化成一个新的纸片，纸片上展现更多的内容； 它的设计规范如下， 项目 数值 标准尺寸 56dp 最小尺寸 40dp 内嵌图标尺寸 24dp 默认z轴位置 6dp 按下时z轴位置 12dp 背景颜色 Accent Color 列表接下来，我们看看另外一个会经常用到的组件列表。 列表用来显示展示类型相同的数据，比如都有头像、名字、职务等信息，不同的只是这些信息的具体内容。 列表项是列表的一个显示单元，列表项的布局不要超过三行，如果确实要超过三行，那么就不应该使用列表来展示内容了。 列表项的内容根据位置的不同，体现出的重要性也不同： 靠左边的内容是最重要的，右边的次之； 靠上边的内容是最重要的，下边的次之； 常见的列表布局有以下三种， 单行：有一行文字的显示 双行：有两行文字的显示 三行：有三行文字的显示 这些布局中各个元素的位置，都在规范中有明确的规定，经过按钮那一小节的讲述，我想大家一定具备看懂规范的能力，能够从中找到设置位置的关键点。 在查看上面的示例时，大家应该注意到了列表项的分割线。这些分割线将列表区域按照逻辑区分开来，都是1dp的宽度。 有的分割线贯穿了整个屏幕； 有的只是将文字的部分分开； 有的没有分隔； to 关于分割线，在Material Design的规范当中，也有专门的章节细致的讲述。 应用栏与工具栏工具栏的作用是把很多操作按钮集中起来，一起展现给用户。它可以放在应用界面的上部分、中间、底部， 在安卓的设计当中，有个ActionBar的概念，它的作用就是展示一个应用的图标、名字，以及菜单、导航栏等内容，从安卓3.0开始它就被提出，并推广了起来。 不过从安卓5.0开始，在ActionBar的基础上提出了AppBar。AppBar除了担当ActionBar的功能外，还增加了一些新的特性，例如滑动效果。新引入的具体的控件ToolBar接替了ActionBar的具体功能，成为AppBar最为核心的组件。 为了便于理解，我举一个例子。Google在2015年进行拆分，成立了多家公司，并将它们规整到Alphabet公司旗下。而以前的Google只保留搜索业务，成为了一个比较单纯的公司。 ActionBar就相当于以前的Google公司；AppBar相当于Alphabet；ToolBar就是Alphabet成立后的Google。AppBar除了ToolBar以外，还可能包含更多组件在其中。 应用栏的高度根据屏幕横竖状态的不同而不同， 屏幕状态 高度 竖屏 56dp 横屏 48dp 应用栏可以根据开发者的要求，变成透明的、半透明的、甚至不显示。 AppBar除了显示标题、菜单等功能外，还有令人炫目的滑动效果，这也是安卓系统使用Material Design的重要特色。 AppBar除了Toolbar以外，可以包含分页标签Tabs 图片等等内容。图片占用的空间叫做可变空间-Flexible space，不一定就是放图片，也可以放其他的元素，只不过就界面设计来讲，显示图片的效果要很多。 AppBar只有Toolbar：内容滚动的过程中，Toolbar可以被顶到消失；也可通过下拉再次出现。 AppBar有Toolbar和Tab： 内容滚动的过程中，Toolbar可以被顶到消失，只留下Tab；也可通过下拉再次出现。 内容滚动的过程中，Toolbar和Tab都被顶到消失；也可通过下拉再次出现。 AppBar有Toolbar和可变区域： 内容滚动的过程中，可变区域可以被顶到消失，只留下Toolbar；也可通过下拉再次出现。 内容滚动的过程中，Toolbar和可变区域都被顶到消失；也可通过下拉再次出现。 状态栏与导航栏用过智能手机的同学对状态栏和导航栏一定不会陌生， 状态栏贯穿了整个屏幕的宽度，高度是24dp。导航栏同样贯穿了整个屏幕的宽度，高度是48dp。不过在很多国内定制的系统当中，因为手机已经有了实体按键，就取消了导航栏。 状态栏和导航栏的背景颜色是可以各自改变的，透明、半透明、不透明。 为了配合不同应用的使用场景，状态栏和导航栏的显示也有不同的表现， 沙发模式（Lean back）：就像在瘫坐在沙发上看电影时一样，屏幕尽可能的呈现视频内容，把状态栏和导航栏都藏起来。这个过程中你几乎不会去接触到屏幕，当你碰触屏幕的时候，状态栏和导航栏才会出现。 沉浸模式（Immersive）：比如当你在使用阅读软件看书的时候，屏幕只显示书本的内容，把状态栏和导航栏隐藏起来，让你沉浸在阅读的快乐当中。但每次翻页的时候，你还是需要接触屏幕的。虽然翻页的过程中接触了屏幕，状态栏和导航栏也不会出现，除非你在屏幕的边缘做了一个滑动的动作，才能将它们再次唤出。 关灯模式（Light out）：当你不碰触屏幕超过一定的时间，状态栏会自动的隐退；导航栏虽然还在那里，但是那三个操作的按钮却变成了三个小点。这个过程就好像是关闭了照亮屏幕的灯，状态栏和导航栏似乎还在那里，只是没有了灯光，已经看的不真切了。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"7 声音与触觉的利用","slug":"2_设计原理/7_声音与触觉的利用","date":"2017-01-10T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/7_声音与触觉的利用/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/7_声音与触觉的利用/","excerpt":"","text":"声音与触觉的利用之前我们对设计的讨论都是几种在视觉基础之上的。但除了视觉，我们人还拥有听觉、嗅觉、触觉、味觉等感知大自然的能力。 现在由于技术的限制，嗅觉和味觉在移动设备领域的使用还无法派上用场，但是听觉和触觉正在扩大对我们使用的影响。 声音的影响最经典的听觉案例有2个，和大家分享一下。 一个是当年诺基亚的开机铃声，我想使用过诺基亚手机的同学每当听到这个声音一定会想到它那经典的台词，科技与人为本，然后就是两只手紧握的图案。这个例子正是通过声音，将用户和手机联系在一起。 还有一个就是iPhone的手机铃声，走在大街上，如果听到这个铃声，很多iPhone用户都会不自觉的去摸一下自己的手机。这个声音改变了用户的行为模式，即使知道可能不是自己的手机在响，但总会下意识去摸一下自己的手机。 与手机铃声不同，短信声音就显得非常短小精干，让你知道短信的存在，也不会太打扰你正在做的事情。 照相的声音、屏幕锁定的声音、键盘打字时的声音…… 每个声音都有它想传达的意境。 触觉的作用触觉能带给用户更好的反馈体验。 当我们不方便开启铃声的时候，震动反馈就能告诉用户有电话来了、有消息需要查收。 苹果公司开发出的感知压力的屏幕，也给界面交互提供了更多的选择。手机通过感知用户按压屏幕时的不同力度，给用户提供不一样的操作响应。 我们可以设想一下这样一个将来会出现的使用场景：用户通过点击屏幕输入文字的时候，屏幕能感受到压力，并根据压力的不同，在被点击的区域产生响应的震动。这样就可以模拟用户打字的力反馈，给用户带来更好使用体验。 对于我们设计师或者开发者来讲，声音和触觉的设计就不属于我们讨论的内容了，它们涉及到另外一个专业的领域。我们还是把精力集中到视觉和功能上的旅程吧。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"6 动画效果","slug":"2_设计原理/6_动画效果","date":"2017-01-09T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/6_动画效果/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/6_动画效果/","excerpt":"","text":"动画效果运动的物体总是能最有效的吸引住人类的注意力。在界面设计的领域，也是一样，当你希望用户的注意力从一个点转移到另一点，在这两点之间设计一个迁移的动画是在合适不过的了。 动画基本上可以分成以下几类： 平移动画： 渐变动画： 缩放动画： 旋转动画 其他所有的动画基本上都是这些单一的动画，或者多个动画的叠加。例如，一边平移一遍放大。 动画由两个要素：一个是上面各种动画体现出的空间变化；另一个就是动画相对于时间的变化。 Material Design从真实的世界当中借鉴了重力和摩擦力对事物的影响，用它们来设计动画在时间维度上的变化。 动画的时间要素一个动画持续的时间要控制在300左右，短了用户看不清，长了太拖沓。 动画变化的速度要平缓，主要有以下几种速度： 标准速度曲线：速度先快后慢 减速曲线：速度从快到慢 加速曲线：速度从慢到快 陡峭曲线：速度变化快速 这些速度是Material Design动画效果的基石。我们看到的那些自然的动画，都是依靠这些速度的配合而形成的。 使用动画的对象为了突出重点，吸引用户的注意力，动画的使用场景可以归纳成如下几点： 应用的界面切换：例如屏幕中进入或者退出一个对象物体。 元素属性的变化：例如屏幕中一个物体的形状发生变化。 内容的迁移：例如通过屏幕中的局部内容展现更多内容。 点击的反馈：当用户点击屏幕时，提供视觉上的动态效果。 界面切换界面切换的效果，根据切换的内容不同，速度也有一些变化： 整个屏幕的切换，动画效果控制在375ms； 小的元素进入屏幕，动画效果持续225ms； 小的元素离开屏幕，动画效果持续195ms； 当一组对象被移动的时候，使用标准曲线， 当一个对象进入屏幕的时候，使用减速曲线，当一个对象离开屏幕不再回来的时候，使用加速曲线， 当一个对象暂时离开屏幕、但随后还要回来的时候，使用陡峭曲线， 元素属性变化 矩形变化：矩形的长宽发生变化。长与宽不同时变化， 长与宽同时变化， 圆形展开：圆形逐渐扩大，展开成矩形， 圆形先做一个平移的动画，再展开成矩形， 合并与分割：多个矩形从分裂的状态聚合到一起形成整体；一个整体分裂开，成为独立的部分， 内容迁移简单的说，就是把显示出的部分内容，扩展成完整的内容， 将现有的内容，原封不动的扩展出更多内容， 视频中的圆形和矩形，在动画前后都保留了下来。只是通过平移和缩放的动画，把之前隐藏的内容显示了出来。 保留关键内容，扩展出更多内容， 视频中的圆形得到了保留，其他元素被隐藏起来。动画过程中显现了更多的界面元素。 点击的反馈为了增加用户点击屏幕时的视觉反馈，Material Design对按钮、列表等拥有点击交互的组件增加了水波纹效果-ripple，","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"5 图标的使用","slug":"2_设计原理/5_图标的使用","date":"2017-01-08T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/5_图标的使用/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/5_图标的使用/","excerpt":"","text":"图标的使用图标能给人带来最直观的印象，有的时候再多的解释也抵不过一个图标。 安卓应用的图标分成两类， 应用图标：在主界面上代表着整个应用的那个启动图标，是给用户第一印象的图标。一个应用开发成功后会不会被用户下载，也许就取决于用户看它的第一眼。 系统图标：在应用里面使用的各种具有特别意义的图标，引导用户进行更多的操作。 应用图标应用图标的设计也是对Material Design的一种体现：制作应用图标的过程，就是对一张纸进行裁剪、折叠、上色、增加阴影的过程。 虽然应用图标可以被设计得千奇百怪，但是它还是有很多的套路可以使用的，只要遵守这些套路，你设计出来的图标也不会难看到哪里去。 先来说说应用图标的一定要执行的规则： Google给出了图标设计的网格图。设计应用图标的时候，要参考这个网格对图案进行布局和排列。 安卓系统希望应用的图标框定在48dp尺寸方框以内，并且拥有1dp的边框（包含在48dp的尺寸以内）。为了作图的细致，建议我们将48dp的图标先放大4倍，也就是变成192dp（边框4dp），再进行设计。 图标可以根据设计线，做成圆角方形、圆形、竖长方形、横长方形。各个形状的区域尺寸分别是： 需要注意的是：虽然图标的形状不同，但是它们都是被限定在了192dp（缩放后）的正方形方框当中；标注出的尺寸都是放大了4倍以后的尺寸。 图标制作的时候，选择简单明了的几何图行。 之后就是和设计相关的要素了。一个图标由7个要素组成： 背景：图标的背景，这个背景的大小是由图标的形状决定的，例如圆角方形、圆形等等，并不占用图标的整个区域。 前景：图标的前景，通常就是表达应用含义的几何图形。 颜色：颜色的选择与应用界面颜色的选择一样，要选择能体现应用内容的色调。颜色不宜不多，最好不要超过3个。颜色可以只是放在前景当中，也可以只放在背景当中。 tint边沿：tint是一个遮罩，可以把它理解成给图层带上了一顶帽子。这顶帽子可以有自己的颜色和透明度，与它盖住的图层混合，显示出不同的效果。我们会在后面详细讲述tint。tint边沿出现在前景和背景的上边沿。它是有规定的： 阴影边沿：出现在前景和背景的下边沿。它是有规定的： 阴影：前景在背景上会留下投影，这个投影也是有规定的： 前景相对于背景的高度是1dp。 光照：图标拥有从左上方45度角照射过来的光源。要注意的是：这个光源仅仅局限在图标的内部。光源的属性如下： 最后我们讲讲前面提到的tint与shade的颜色。tint与shade都是在原来图层的上方添加一个遮罩，让遮罩与图层叠加，产生不同的颜色效果。 首先确定主色调的类型：冷色？暖色？ 根据下表，选择tint与shade的颜色。 例如主颜色是Yellow 500，它属于Warn暖色。因此， 它的tint颜色就是主颜色添加20%的白色。 它的shade颜色就是主颜色，添加20%的Deep Orange 900 系统图标下面这些常见的图标都是系统图标。 它们都是使用粗线条的几何图案，非常简约。设计系统图标也是很套路的事情。 先来说说应用图标的一定要执行的规则： Google为这个类型的图标设计了网格图， 安卓系统希望应用的图标框定在24dp尺寸方框以内。 图案在20*20以内，多余的4dp作为边框空着。 图标可以根据设计线，做成圆角方形、圆形、竖长方形、横长方形。各个形状的区域尺寸分别是： 需要注意的是：虽然图标的形状可能不同，但是它们都是被限定在了24dp的正方形的方框当中。 之后就是和设计相关的要素了： 图标的外部边缘都是2dp的弧形，而内部边缘都是方形； 做图的笔划粗细要一致，而且笔划是方形的。笔划掉粗细是2dp。 假如图形很复杂，2dp实在是显得拥挤，那可以适当用细一些的笔划，例如1.5dp。如果还很难画，那就的想想是不是你的图标太复杂，要考虑更简单的图案了。 图标在界面上布局的时候，要让它拥有额外的边距。加上边距，整个图标的尺寸要达到48dp。也就是说，它上下左右的边距要有24dp。为什么呢？因为系统图标大多是需要让用户点击的，经过测试，人的手指点击时接触屏幕的区域大小差不多就是48dp。 此外，在使用几何图形作为图标的时候，要选择平面的图形，有3D效果的就不需要了，因为Material Design是扁平化的设计。 系统图标的颜色设置也有需要遵循的规则，在亮暗不同的背景下，颜色不同， 在亮背景下，使用黑色： 在暗背景下，使用白色： 工具知道了制作图标的规则，一切就好办了。如果你是设计高手，可以用工具，从无到有，完全自己画一个图标。如果你时间有限、不善此道，那么可以从网上找到很多设计图标的素材。 Google在官网上放出了很多现成的图标素材，涵盖了很多门类，基本上够我们直接拿过来使用了。 阿里也提供了一个收集了很多图标的网站iconfont，我们需要某个类型的图标时，可以去上面搜索。这几乎一定能满足我们的需要。 制作图标的素材最好是矢量图，这样随便缩放素材的大小，图案的边缘都可以清晰可见。而且向我们要使用的图标素材都是很简单的几何图形，矢量图占用的存储空间会非常的小。 还有一个实用的图标制作工具网站Android Asset Studio。你可以选择制作应用图标或者系统图标，调整好参数以后，就能将图标下载到本地使用。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"4 文字的使用","slug":"2_设计原理/4_文字的使用","date":"2017-01-07T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/4_文字的使用/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/4_文字的使用/","excerpt":"","text":"文字的使用文字是应用当中使用最多的要素。显示一段供用户阅读的文字，程序运行时的信息提示都离不开它。 文字是内容的实际体现者，因此设计师需要将用户的注意力尽可能的吸引到文字当中。 字体可以分成两种类型：有衬线的-serif；无衬线的-sans-serif，也简称sans。serif的笔划端部会多出来一截修饰；sans的笔划端部是平的。 在过去，serif通常用来做文章的内容，sans用来做标题；但是现在，内容也开始使用serif了，这是一种新的趋势。在安卓系统中，就采用了sans字体做文字的默认显示。 不同的文字内容，需要吸引用户不同程度的注意力。例如，按钮上的文字和内容都需要吸引用户的注意力，但是它们的重要程度是不一样的。这种吸引的程度可以通过字体的大小和字体的颜色来实现。 字体前面提到的serif与sans-serif是通过衬线将字体分成了2类。接下来我们开始认识认识字体。 从文字的形状出发，可以将文字分成三类， English-like：英文、拉丁文等字母组合型的文字； Tall：像阿拉伯文字、泰文这种像绘画片段组合成的文字； Dense：像中文、日文、韩文等具有高密度笔画等文字； 我们主要进行中文应用的开发，所以会遇到很多Dense类型的字体。 字体和某个具体的字体是两个不同的概念，前者是对具有相同间架结构文字的总称，是个很宽泛的概念；而具体的字体指的是使用时，为了显示某个文字而具体使用的文字形状。 例如Arial字体，它下面就拥有多个子项目-字体家族。 字体家族-font family是一个家族的名字，它的下面可以有多种字形-style。例如Arial字体家族，它就拥有多个字形：Regular-常规 Italic-斜体 Bold-粗体 Bold Italic-斜粗体，这几种字形也是其他字体家族中最经常具有的。 某个具体的字体，例如Arial Regular，就是由它所在的字体家族和字形来决定。所以每说到一个具体的字体，都可以找到它对应的字体家族和字形。 例如下面的Arial Arial Black Arial Hebrew，分别对应着3种不同的字体家族；而每个字体家族下面都有各自具体的字型。 可以看到，有的字体家族下面可以只存在一种字形，也可以存在多种字形。这就完全看字体设计师的实现了。 例子里面的字体都是Arial字体，它下面的子项名称中虽然都有Arial，但都属于不同的字体家族。 Noto对于Dense类型的文字，安卓系统使用Google提供的开源字体Noto。 Noto字体家族本身拥有了很多字体：Noto Sans，Noto Serif，Noto Momo……。 Noto拥有从英文字母到汉字的所有文字，对于我们开发中文应用，完全没有问题。显示简体中文的时候，使用的是Noto Sans CJK SC。 Noto有7种字形：Thin，Light，DemiLight，Regular，Medium，Bold，Black。它们对应的具体字体的粗细是各不相同。 关于Noto字体名字的由来，还有一个这样的小故事： 电脑中显示字符的时候，如果系统中没有安装对应的字体，那么就会在屏幕上显示一个空白的方框-口来代替。如果连续出现很多个不能显示的文字，显示的内容就像是口口口口口。外国人觉得这个方框像我们中国的豆腐，于是就叫它tofu。为了消灭这些豆腐，No tofu的口号就成为了Noto的名字。看来Noto为此发了大愿，消灭文字显示中的一切盲区。 大家可以在Google提供的官方网站获得Noto字体更为细节的信息。 Roboto对于English-like类型的文字，安卓系统使用Google提供的开源字体Roboto，它看上去要宽且圆润，现在在很多平台上得到了广泛的应用。 Roboto有6种字形：Thin，Light，Regular，Medium，Bold，Black。 Roboto与Noto是兼容的，当选定Roboto的一种粗细的笔划时，就能在Noto当中找到对应粗细的笔划。 大家可以在Google提供的官方网站获得Roboto字体更为细节的信息。 大小不同的位置，文字显示的大小也可能有所不同。Material Design对界面上各个显示元素中使用到的文字大小，作出了规定。 显示English-like内容的时候，在中文系统中显示英文： 显示的位置 字体类型 字体大小 Display 4 Light 112sp Display 3 Regular 56sp Display 2 Regular 45sp Display 1 Regular 34sp Headline Regular 24sp Title Medium 20sp Subheading Regular 16sp Body 2 Medium 14sp Body 1 Regular 14sp Caption Regular 12sp Button Meduim 14sp 显示Dense内容的时候，在中文系统中显示汉字： 显示的位置 字体类型 字体大小 Display 4 Light 112sp Display 3 Regular 56sp Display 2 Regular 45sp Display 1 Regular 34sp Headline Regular 24sp Title Medium 21sp Subheading Regular 17sp Body 2 Medium 15sp Body 1 Regular 15sp Caption Regular 13sp Button Meduim 15sp 规律就是，显示正文时（从title开始），中文比显示英文要大1sp。 Display对大家来说可能比较陌生：它的用法是将文字作为一个大区域的显示，例如手机待机时屏幕上显示的时间信息，就是将文字当作Display来运用的。 格式为了便于用户阅读，让用户有良好的阅读体验，我们还要考虑文字当中， 行之间的间距。 每一行占据的宽度。对于长段的内容，字符控制在60个每行；对于简短的内容，字符控制在30个每行。 颜色文字使用的颜色与背景的颜色相关，采用白色或者黑色，目的是提高文字的可读性，不要让文字的颜色和背景的颜色混在一起。 文字的颜色需要根据显示的位置体现出不同的深浅颜色。这种颜色的深浅是通过调整字体的透明度实现的，而不是将字体设置成一种灰色。 字体颜色安卓系统根据显示内容的重要性，将文字主要分成了好些类：textColorPrimary textColorSecondary textColorPrimaryActivated textColorSecondaryInverse 等等。不过最重要的就是： textColorPrimary：就是Primary text-主要文字内容使用的颜色。它使用在文字的title，headline，subhead，Body1～2，Button这些位置。 textColorSecondary：就是Secondary text-次要文字内容使用的颜色。它使用在Display 1～4，Caption这些位置。 浅色背景对于浅色背景，字体使用纯黑色-#000000，根据使用场景的不同，透明度不同， 使用的场景 透明度 Primary text 87% Secondary text 54% Disable text, Hint text 38% 假如文字需要与图标配合使用，那么文字的颜色也是使用纯黑色-#000000，但是会根据图片当前是否处于激活的状态而不同， 图标激活状态 图标对应文字的透明度 激活 54% 未激活 38% 深色背景对于深色背景，字体使用纯白色-#FFFFFF，根据使用场景的不同，透明度不同， 使用的场景 透明度 Primary text 100% Secondary text 70% Disable text, Hint text 50% 假如文字需要与图标配合使用，那么文字的颜色也是使用纯白色-#FFFFFF，但是会根据图片当前是否处于激活的状态而不同， 图标激活状态 图标对应文字的透明度 激活 100% 未激活 50% 字体的下载和使用前面提到的Noto字体和Roboto字体，可以分别在Noto的官网 和Robot的官网看到更为详细的介绍，并下载。 假如你的电脑上并没有安装这两种字体，请去官网下载。 下载以后(这里用安装Noto的简体中文字体来举例), 将得到的压缩包解压； 依次双击字体文件*.ttf或*.otf； 这样就可以将这些自己安装到电脑上了，在设计的过程中，就能够选择到对应的字体了。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"3 颜色的运用","slug":"2_设计原理/3_颜色的运用","date":"2017-01-06T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/3_颜色的运用/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/3_颜色的运用/","excerpt":"","text":"颜色的运用Material Design采用的是扁平化的设计，可以看到一大块一大块区域的颜色。这些颜色大多亮丽引人，整个界面上搭配的颜色也不会太多，基本保持在三种颜色以内。 “没有错误的颜色的，只有错误的搭配”。颜色是没有对错的，我们要用经验和直觉来搭配它们，所以要先来认识认识颜色。 颜色理论颜色是有语言的，红色代表这热情奔放，蓝色代表的沉着安静，绿色代表着生机活力。搭配一组颜色，就是表达作品要传递的含义。 我们大部分人都知道RGB颜色，它的理论依据是：任何颜色都是通过不同强度的红色R、绿色G、蓝色B组合而成的，改变它们的组合就能得到任何颜色。在计算机领域，这三种颜色分别具有0～255个不同的数值。 对于设计师配色来讲，还会使用另外一个体系的颜色理论-HSB：色调H，饱和度S，亮度B。 我们人在谈论颜色的时候，总是说这个颜色很红、有点绿、偏蓝。 当我们说很红的时候，就是给颜色设定了一个基调-红色。这种基调称为色调。色调成圆环形状的分布，依次渐变的呈现出赤橙黄绿青蓝紫各种颜色。 色环具有360度，因此色调的数值就是0～359度。色调数值从0到359变化，也代表着颜色从暖色逐步过渡到冷色。你是不是看到红色就觉得温暖，而看到深蓝色就觉得冷飕飕的呢？ 很红的很字，就要通过饱和度和亮度来体现了， 饱和度：可以理解成把一种纯粹的颜色溶解到水里面，如果水很多，颜色就很淡；如果水很少，颜色就很纯。因此它具有0%～100%的数值。 亮度：我们能看到物体是因为光线照在物体上面的缘故。如果一点光没有，不管什么样的颜色，看起来都是黑的，只有充足的光线才能反映出物体本来的颜色。因此它具有0%～100%的数值。0%说明没有光照，那么就会是黑色。 如果你的本行并不是设计师或者刚入行不久，在给安卓应用配色的时候一定会犯迷糊，不知如何选择。幸好Google已经考虑到了这点。它从360度的色环当中，为大家选择出了非常适合做界面设计的色调，并通过调整这些色调的饱和度和亮度，得到了一系列可以与主色调搭配和谐的颜色（实际上，这些色调与主色调可能有细微的偏差，比如说3度）。这些颜色放在一起，被形象的叫做调色板。 例如， 这些颜色都给出了对应的RGB数值，也给出了它们自己的名字，例如500，100，200，……，A700，数值越高，颜色越深。其中带A的，表示这个颜色推荐用来作为Accent Color（Accent color接下来会马上介绍到。）。 通过数字给颜色编号，这是为了方便设计师与开发者之间的沟通，给这些颜色取的名字。当他们谈论某个颜色的时候，只需要说出颜色的名字，大家脑中就会产生一个直观的印象。如果他们讲RGB值，大家都会觉得很难想象。 选择颜色通常来讲，一个应用界面当中，不要超过三种不同的色调，否则色调的差异就会过多的吸引使用者的注意，把关注点从内容上分散到各个不同的颜色上去了。 为了简化设计师的工作，Google的Material Design只需要选择Primary Color Primary Dark Color Accent Color三种颜色，就能确定整个应用的整体配色方案。 当设计师要给一个应用选择颜色的时候， 可以会从色环当中选择一个设计师认为合适的颜色。 也可以从Google提供的调色板中选取。这些颜色都是Google千挑万选后的结果，如果大家没有特别的原因，就使用这种表现稳健的颜色吧。 Primary ColorPrimary Color是一个应用使用最为广泛的颜色，它决定了一个应用整体的基调。界面中很多的元素都会使用到这个颜色。 比如，主颜色选取Indigo 500。 Primary Dark Color选定主颜色之后，通常还会在主颜色的附近，选择一个暗色作为搭配，例如Indigo 600～900作为深色。这个颜色通常只是体现在状态栏的颜色上。 除了暗色，有时还需要使用与主颜色相配合的亮色，例如Indigo 500作为主色之后，Indigo 50～400，都是亮色可选的对象。 Accent ColorAccent Color是与Primary Color完全不同的一个色调，用来吸引用户的注意力，比如用在按钮、进度条等等需要用户关注的、有交互功能的组件上面。如果Primary Color与Accent Color是不同色调，设计师可以自由的选择；如果Primary Color与Accent Color都是同一种色调，那么确定Accent Color的时候，通常使用Google调色板中名字里带A的颜色，例如A100～A700. 常用工具使用Google提供的调色板进行配色的时候，如果能够快速的查看配色完成后的效果就好了。 Material Palette为我们提供了这样的方便。当选中期望的Primary Color和Accent Color以后，右边的预览界面就会立刻看到搭配的效果。确认搭配方案之后，还可以下载配色的方案到本地，便于将调色板导入界面设计的软件当中直接使用。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"2 界面布局","slug":"2_设计原理/2_界面布局","date":"2017-01-05T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/2_界面布局/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/2_界面布局/","excerpt":"","text":"界面布局布局涉及到应用界面的整体。布局的层次感和逻辑，可以通过阴影来体现。 举个例子。在一张纸当中，增加一条折痕，一个区域就分成了关联性很强的两个区域， 将一张纸盖在另一张纸之上，就像是搭台阶一样，上层会在下层投下阴影，这两张纸代表了逻辑不同的两个区域， 纸张在z轴的位置，被称作Elevation，很形象的比喻了纸片相对于别的照片被提升了起来。 尺寸的度量张纸片之间的距离产生阴影，那么距离用什么来衡量呢？要解答这个问题，我们首先要知道像素-px，物理尺寸-inch，像素密度-dpi和密度无关像素-dip这几个概念和它们之间的关系。 安卓系统提供了几种度量屏幕的单位： px：以像素为单位进行设置，屏幕上每一个点，就是一个像素，例如一部安卓手机，屏幕像素是1920 x 1080，就是说屏幕高度有1920个像素点，宽度有1080个像素点，但是在安卓系统中，最好不要使用这个单位来设置尺寸，而是用dp； sp：用于字体大小的设置，它可以让字体大小根据用户在设置中的设置，进行缩放； dp：密度无关像素，这是在布局和控件中应该使用的单位； dp的引入如果用px为单位设定设备区域的大小，通常会有很大的问题。 假设有两个物理尺寸都为5寸大小的屏幕，它们的屏幕分辨率不同，一个是1080*1920，而另一个却是450*800. 如果指定一个按钮的大小为200px长，200px宽，那么它们的显示效果就如下图。很明显，两者的差别也太大了，界面就严重变形了。所以，想让一个区域的大小在不同屏幕的上显示的都差不多，就需要考虑像素密度。为了显示同样的长度，在密度大的屏幕上，使用到的像素就要多一些，在密度小的屏幕上，使用到的像素就要少一些。 所以为了解决这个问题，安卓引入了dip的概念－device independed pixel－简称dp。 dpi的定义在近一步介绍dp之前，要先讲讲dpi。dpi叫做屏幕像素密度，就是每英寸有多少个像素点。我们用简单的数学原理-勾股定理就能算出刚才两个屏幕的dpi，一个是440dpi，另一个是184dpi。 注意，dpi与dip(dp)写法很像，千万不要混淆了，前者和密度有关，后者与像素有关。 dpi的划分安卓使用dpi为160的数值作为一个基准－－baseline, 如果一个设备的dpi刚好等于这个基准，那么它就是mdpi设备； 如果一个设备的dpi是这个基准的1.5倍，那么它就是hdpi设备； 如果一个设备的dpi是这个基准的2倍，那么它就是xhdpi设备； 如果一个设备的dpi是这个基准的3倍，那么它就是xxhdpi设备； 这就是划分不同屏幕密度的依据。 像素密度类型 像素密度大小 与Baseline比值 mdpi 160 1 hdpi 240 1.5 xhdpi 320 2 xxhpi 480 3 按照这样的约定划分， 刚才1080*1920的屏幕应该属于xxhdpi类型； 450*800的屏幕应该属于mdpi类型； 现在的安卓手机几乎都在往高清屏幕发展，所以xhdpi和xxhdpi是最为常见的设备类型。 dp与px的关系安卓引入了dp(dip)的概念之后，实际显示的像素就可以通过下面这个公式计算出来 px = dp * dpi / 160。 相同dp的情况下，密度大的设备，实际像素就占的大，密度小点设备，实际像素就占用小了。因此使用dp这个单位后，按钮在两种不同的屏幕上的实际显示大小，几乎就是一样的了。 例如刚才两种屏幕。如果我指定按钮的大小为200dp*200dp，那么它们在各自的屏幕上占用的实际像素分别是230px*230px与550px*550px，真实设备上看上去的确差不多。 所以，我们以后在设计界面布局的时候，就可以在标准大小（mdpi类型，尺寸为360dp*640dp）的屏幕上，使用dp为单位进行设计就可以了。 了解了安卓系统使用的尺寸衡量标准以后，我们就可以开始研究布局的逻辑区域划分了。 布局的整体划分安卓系统的界面大致可以分成三个部分：状态栏、内容区域、导航栏。 状态栏显示电池电量、手机信号、通知等信息。 导航栏显示返回、主界面、最近打开等三个虚拟按钮。 不过很多设备通过硬件按钮实现了这三个功能，所以就没有虚拟按键了。 内容区域就是给程序使用，显示程序自身内容的地方。它里面的内容也是像纸张一样，一层一层的堆放着的。 正如前面提到的那样，这三个区域也是像纸片一样，是层叠起来的，在z轴上存在空间关系。 内容元素状态栏和导航栏的各个属性都是系统的，无法去进行z轴位置的控制，因此我们不必太过关注。各种不同的应用使用内容区域来显示各自的内容，这才是我们要讲的重点区域。 虽然这个区域的内容怎么显示都是由各个应用说了算，但是Material Design给出了推荐的设计。 在内容区域当中，可以通过折痕、阴影等方式将这些区域划分成不同的逻辑块。 下面是一个典型的Material Design布局（只是一个典型，并不是都这样，具体的布局方式还是要设计师来设计）。 AppBar每个应用都有一个标题栏，叫做AppBar，它不仅可以显示这个应用的名称，也可以把更多的操作-Action放在上面，比如搜索，分享，更多等动作。 它的位置处于z轴4dp处。 Float Button悬浮按钮是Material Design中一个很重要的特色。它是一个圆形的按钮，悬浮于内容区域的最上面。当我们按下这个按钮的时候，它就会进一步的浮动到更靠上的位置。 当它没有被按下单时候，位于界面布局的z轴上6dp处，当它被按下单时候，z轴位置被调整到12dp处 其他除了上面的提及的几种内容元素意外，安卓系统还提供了很多别的元素，比如Dialog Picker Menu Button等等，它们在z轴上都有自己的位置， 至于每个元素在Material Design中长什么样，我们会在后面的章节介绍。 除了前面介绍的这种典型布局，还有很多其他的布局，我们也是放到后面专门的章节来介绍。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"1 设计原理","slug":"2_设计原理/1_设计原理","date":"2017-01-04T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"2_设计原理/1_设计原理/","link":"","permalink":"http://booktest.anddle.com/2_设计原理/1_设计原理/","excerpt":"","text":"设计原理设计是一门让人感觉很抽象的艺术。设计需要从两个方面来考虑问题： 实用：体现在功能上和交互性上； 美观：体现在界面的布局，色彩的搭配，字体的运用上； 对于我们的安卓应用来讲，设计的目的就是要体现需要显示给用户看的内容的价值，将用户所有的注意力都吸引到要呈现的内容之上。 对安卓应用来讲，这些内容无非就是：文字和多媒体（视频、图片等等）。 在这里游戏就不是我们讨论的范畴了。 围绕内容，Google为此提出了一套针对于此的设计原则。 Material Design简介Material Design是Google专门为安卓应用开发而规定的一套设计语言。 在Material Design提出以前，安卓系统当中存在过两种不同的设计风格，每种风格都有暗Dark 和亮Light两种表现形式。例如， 安卓系统最早问世的时候，界面风格是这样的， 后来在经历到安卓3.0点时候，设计了Holo主题， 需要注意的是，当时这两种风格只能被称作安卓应用的主题，还没有上升到设计语言的高度。因此当时的应用，交互界面被设计的千奇百怪，拿着安卓手机，打开不同的应用（除了Google原生的应用），感觉很不协调。例如应用A的新建按钮放在左上角，而应用B的新建按钮又放在右下角，虽然可以这样设计，但是用户的使用体验不一致。 为了减少这种设计分裂的问题，Google从安卓5.0起，就提出了名叫Material Design的设计语言，倡导各位App的设计者，根据Material Design规范中的建议来开发应用，不要都去自创门派。 这套规范就规定了应用的， 实用性-交互方式； 美观-布局、配色等等 为了与Material Design配合，从安卓5.0开始，Google中安卓系统当中增加了Material主题。因此系统当中形成了原始主题、Holo主题、Material主题三者并存的状态。 从安卓5.0开始，Google强烈建议大家按照Material Design进行开发了。 当然这个规范也只是个建议，开发者实在不去使用，Google也没有办法 为了让Material Design的设计规范能容易的被程序开发者实现，Google在开发工具上也给出了相应的支持，从界面布局的设计到控件的使用，都提供了全套的支持。我们讲在后面程序开发的部分，对这些技术支持进行详细的介绍。 Material Design的理念在Material Design存在以前，我们已经经历过了拟物设计。最早的iOS系统就是拟物设计典型的代表。 后来出现了扁平化设计，将以前立体的设计都拍扁，平摊在屏幕之上。 后来Google为了保持扁平化设计简洁，增加交互的立体感，提出了Material Design。 Material Design是基于印刷品的理念来设计的。真实世界中，我们依靠阅读获取大量知识，Google将我们的屏幕想象成印刷着各种内容的载体。书是一页一页的，对应着屏幕上呈现内容的每一个区域，每个内容区域就是一种材质。它们就像一张张纸片，通过纸片摆放的位置、纸片间的运动，展示应用中不同的功能。 例如，通过两张纸片通过阴影的效果，反应了它们在3D空间中的位置关系， 对位于不同层次的一张纸片来说，它的移动不会影响到另外层次的纸片。 因此可以想见，采用Material Design的应用，界面的层次感应该是呈堆叠状的， 因此我们说MaterialDesign将扁平化与位置关系结合了起来。 Google给Material-纸片定义了一些基本的特点： 每一张纸片的厚度都是1个单位（就是1dp，dp的概念我们将在后面详细介绍）； 纸片之间都有z轴方向上的位置关系，有阴影效果； 纸片上显示的内容是直接印在纸片上的，没有厚度，内容显示的区域限定在这张纸片之上； 纸片上下层关系一旦确定就不能变化了，不允许纸片上下移动时的穿透； 纸片的形状和大小是可以变化的； 纸片不能被折叠 设计的秘诀当设计师拿到框线图之后，就需要使用Material Design的设计语言来改造。所以，对于刚接触设计的我们来讲，要首先要学习的就是Material Design的种种套路。 不要被Material Design的概念吓唬到，将它分解成我们熟悉的内容，逐个掌握它的设计精髓。 内容的展示Material-纸片，是用来展示具体内容的。 这涉及到了， 字体的选择、字体大小的设置、文字内容的排列方式。 图片的大小区域、展示方式。 逻辑的体现配色以及纸片的位置关系，是用来体现内容与交互之间逻辑关系的。 这涉及到了， 给material纸片配色。 界面模块的布局方式。 系统图标的样式、放置规则。 动画效果的设定。 声音、震动等辅助效果的使用。","categories":[{"name":"第2章-设计原理","slug":"第2章-设计原理","permalink":"http://booktest.anddle.com/categories/第2章-设计原理/"}],"tags":[]},{"title":"2 功能","slug":"1_创意/2_功能","date":"2017-01-03T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"1_创意/2_功能/","link":"","permalink":"http://booktest.anddle.com/1_创意/2_功能/","excerpt":"","text":"功能的确定产品的功能并不是在确定了产品之后才开始考虑的，功能与创意选择其实是一个“你中有我，我中有你”的关系。为了体现产品设计的阶段性，我才将它单独提出来分析。 这里讨论的产品功能，是建立在选定了某个基础之上的。比如我们之前选定了天气预报，那么就将产品功能围绕天气预报讨论。 头脑风暴一开始，我们可以对产品进行一次头脑风暴，找出它的核心功能和可以拓展的外延。 什么是头脑风暴？ 简单来说，就是给定一个主题，让一群身份不同的人漫无边际的想一些点子。之后将这些点子归类整理，进一步讨论它们的可行性和重要性，最后形成一个提案。 在我们这里，可以简单的理解成：为了挖掘产品的潜在的功能，我们先不管能不能实现，不管实现了有多大的意义，不管要付出多大的代价，是把我们能想到的功能都找出来。 进行头脑风暴的人最好由不同行业、不同背景的人组成，这样考虑的问题就能多角度，更全面。不过即使只有你一个人也行，毕竟你要做一个能让自己满意的产品才会感觉到快乐，对吧。 方法1可以将我们风暴的内容，写到小纸条上，贴在黑板上， 风暴结束后，将这些小纸条按照内容进行分类整理出来， 最后按照功能的重要性、相关性，形成我们的功能列表， 方法2在电脑上用思导图软件，将风暴的内容写在上面，例如使用Mac平台上的MindNode， 然后通过拖动的方式将它们进行整理， 最后再形成功能列表。 除了头脑风暴，我还可以去软件市场下载同类型的产品，逐个研究它们具有哪些功能，对那些确实优秀的功能点加以优化，做出修改，进行微创新。 举例我们先来风暴一下天气预报要有些什么样的功能： 能够连接网络，从网络获取数据，用来显示； 能够将获取的数据，例如当日的温度、湿度、风向、是否晴天下雨、紫外线指数、穿衣指数、污染指数等等，显示出来； 可以显示当日之后多天的预报，采用曲线图的方式呈现； 可以显示当日之前任何日期的实际天气情况； 能够设定当前的位置，获取天气情况； 能够配合当前的天气，显示一张合适的背景，比如下雨的时候，背景就是一张雨景的照片； 能够配合当前的天气，显示动态的背景，比如下雨的时候，背景就是雨水滑落的动态效果； 能够接收提醒，比如下雨了，发出一个通知提醒用户带雨伞； 能够提供一个桌面小工具，在桌面就能查看到天气信息； 天气数据到的源可以选择，阿里提供的、雅虎提供的、腾讯提供的、百度提供的，都可以切换； 虽然我们还可以风暴出很多天气预报可以具有的功能，但是作为第一个例子，我们暂时就列出这么多吧。 接下来将功能分类，有的分类项也许有重叠，但是没有关系， 外观类： 配合天气显示的背景：动态图或者静态图； 显示温度、湿度、风向、天气、紫外线指数、穿衣指数、污染指数； 未来天气的预报，采用变化的曲线表示； 桌面小工具； 功能点： 通过网络获取天气数据； 多个天气数据源的选择； 多个地点的位置设定； 桌面小工具 提醒功能； 多天预报； 历史天气查询； 选定功能列出一堆的功能后，我们就要考虑给他们排列个重要程度了，确定哪些功能是必须的，哪些是可选的，他们实现起来复杂度有多大。 对于复杂度很高的功能，我们可能还要进行一次头脑风暴，理清楚它的重要性，看能不能把它分解成相对简单的功能来加入。如果不能，那么可能就得暂时放弃了。 有的功能可能还要依据现有的素材，看能不能提供，例如紫外线指数，如果网络端都没有这样的参数，那写在功能列表里面也是没有用的。由此我们也可以看出，头脑风暴之后，多种成员参与的重要性，如果有一位开发者，他可以很快的判断这个功能点从技术上讲实现起来是否可行。 技术验证坦白的讲，技术验证并不是在功能确定之后才开始进行的。它应该在确定功能的时候给予技术上的配合，告诉方案的提出者：“这样的功能从技术上讲是可以（不可以）办到的”。 能越早回答这样的问题，就能越早发现并减少项目的风险。 在天气预报当中，最需要验证的并不是设计出一个界面设计出来后能不能做出来，而是去哪里获取天气数据。 天气数据才是功能的核心。从哪里获取数据呢？ 我们没有自己的观测站，所以数据肯定是要从其他公开的渠道获取：通过网络蜘蛛爬取；通过第三方提供的标准API接口获取，例如阿里提供、雅虎提供、腾讯提供或者百度提供。 假如我能获取到第三方的数据，那么我是否需要自己建设一个提供天气信息的服务器呢？ 就我个人来讲，我希望使用自己的服务器提供天气数据，把收集到的数据都整理到自己的服务器上，一旦某一处的数据出现问题，还可以自动切换到别处的，拥有更好的健壮性。 此外，我也可以自己定义天气数据的查询方式和回传内容，可操控性更好，不会担心数据源的格式发生改变，造成应用获取数据出错的问题。 因此我决定搭建一个服务器，为大家提供这样的数据获取方式，就不麻烦大家将精力分散到与安卓入门开发关系不大的领域去了。 不过，我这里提供的数据都是构造出来的，并不能真实的天气数据，目的只是为了帮助大家学习开发一款应用。毕竟去抓取网络数据有要花费额外的心思，偏离了我的本意。 至此，我们不需要为数据展现的内容而担心了，只要能想到的数据，我都可以在服务器端通过构造产生。之后的界面设计，就需要根据这些能获取到的信息来设计， 数据项 描述 取值 实时温度 当前查询时的天气温度 整数数值 实时风力 当前查询时的风力大小 0-17级 实时风向 当前查询时的风向 东 西 南 北 东南 东北 西南 西北 实时天气 当前查询时的天气状况 晴天、雨天、多云、多云间晴、雾、雪 当日温度范围 当日温度范围 整数数值范围 实时空气质量 当前查询时的空气质量 优 良 轻度污染 重度污染 不利于生存 空气湿度 当前查询时的空气湿度 0-100% 运动指数 当前查询时的运动指数 非常适合 适合 不适合 紫外线指数 当前查询时的紫外线强度 强 中 弱 未来5天预报 未来5天天气状况、最高最低温度 功能筛选下面，我们就来分析一下这些功能，并为它们的重要性和难易程度作出评价。评价的原则很简单：我们只是为了展现开发的各个关节，所以尽量把功能做的简单，降低我们第一次的学习门槛 外观类： 项目 分析 难易程度 重要性 静态图背景 放一张静态图片即可 易 中 动态图背景 设置循环的动画效果 难 中 显示温度、湿度、风向等天气指数 具体显示哪些数据依赖于数据源 易 高 天气变化的曲线表示 这需要一个做曲线图的特殊组件 难 中 桌面小工具 安卓系统提供了桌面工具的框架机制 中 中 功能点： 项目 分析 难易程度 重要性 通过网络获取天气数据 这功能必须有，不然就没有显示的内容 易 高 多个天气数据源的选择 访问自己架设的服务器，不需要用户去选择 易 低 多个地点的位置设定 刚开始简化一点，只提供当地的天气预报，由服务器决定 易 低 桌面小工具 安卓系统提供了桌面工具的框架机制 中 中 提醒功能 需要网络端支持主动的推送数据 难 低 多天预报 天气类App的标配 易 高 历史天气查询 意义不大，用户更关心未来的天气 中 低 我们把重要性低的、开发难的功能暂时放一放，于是得到了下面的功能清单： 通过网络获取天气数据； 显示天气预报的位置； 显示当前时刻的：温度、温度变化范围、湿度、风向、风力、天气、紫外线指数、运动指数等信息； 未来5天天气预报，包括天气状况、温度变化范围； 此外，为了近一步简化开发，我们还可以假定：所有的数据都是从网络获取，如果没有网络，那么就不能获取到天气信息。也就是说获取到数据不需要存储到手机上，这一点又降低了开发的难度。 功能流程确定好功能后，就要根据这些功能，为应用设计一套使用的逻辑，比如需要几个界面，每个界面做些什么事情，这些界面都要覆盖到所有的功能点。 天气预报的流程也许就是这样： App启动之后，自动去网络获取信息； 当日天气信息和近日的预报信息需要展示到界面上，但是具体怎么展示就要看设计阶段的设计方案了； 流程的设定和设计阶段有一定的交集。前者只是一个原则上的草图，而后者将会从设计的角度打磨出一款精品。 这时候的草图叫做框线图，就是一个手稿，一个示意图。这张图还要交给设计师，和设计师一起讨论设计的方案，再由设计师重新操刀，进行大刀阔斧的修改，将草图蜕变成真正的产品形态，最后形成高保真图、产品原型和UI素材。 下一版功能对于那些我们没有被选定进来的功能，我们可以将它们放到该App下个版本当中。例如，位置的设定，桌面小工具，天气预报的曲线图等等。 未来版本的天气预报App不仅需要修复之前存在的设计缺陷，也要加入新的功能，让用户获得更好的使用体验。","categories":[{"name":"第1章-创意","slug":"第1章-创意","permalink":"http://booktest.anddle.com/categories/第1章-创意/"}],"tags":[]},{"title":"1 创意","slug":"1_创意/1_创意","date":"2017-01-02T01:00:00.000Z","updated":"2017-02-17T03:09:56.000Z","comments":false,"path":"1_创意/1_创意/","link":"","permalink":"http://booktest.anddle.com/1_创意/1_创意/","excerpt":"","text":"创意我们总会羡慕、崇拜那些创造出了伟大产品的人。提到乔布斯，大家一定会竖起大拇指，他创造出了革命性的ipod、macbook、iphone、ipad等等极具创意、使用方便、同时又设计优雅的产品。 对于从事软件行业的人来讲，最有成就感的事情莫过于开发出一款让人交口称赞的应用软件了。 来源好的产品要有好的创意，人对创造产品的创意来自于哪里呢？ 我觉得产品的创意来源于三个方面： 最直接的创意来源于自己的实际需要。比如，曾经有位程序员想写一部小说，他尝试了市面上很多文字编辑器，觉得都不能满足自己的需要，于是就自己开发了一款。最后，他原打算要写的书没有了下文，但是却创造出了Mac系统上非常经典的应用-Ulysses，成为了很多作家的创作利器。Ulysses将写作爱好者的写作体验带入了天堂。 更多的创意来源于对现有生活的归纳总结。用智能手机听音乐，几乎是每个使用者的刚性需求，所以开发一款音乐播放器的灵感就很容易跑进我们的大脑。 还有的创意来源于对现有产品的差异化。例如音乐播放器这样的刚需应用有很多，QQ音乐、阿里音乐，虾米音乐，酷狗音乐，安卓系统自带的音乐播放器等等。不过网易云音乐在众多的音乐播放器中脱引而出，依靠的正是它对其他类似应用差异化的挖掘–基于音乐的社交模式。 标准好的创意是什么？我的理解是： 实实在在的解决了一个问题，至少它能让我们觉得方便了我们的工作或者生活。 它的解决方法很简单，不需要复杂的操作，也许简单的让人意想不到。 产品的外观设计的深入人心，一看到它就有使用的欲望。 记录工具创意宝贵，可能我们一转眼就把它忘记了，所以我们要能随时将它们记录下来， 最传统的方式就是笔和纸，好记性比不过烂笔头，随时带着一个小本子和笔，一旦有了产品的灵感，就把它记录下来。 iPad和apple pencil也是一对极好的搭档，用电子的方式做记录能便于我们做后继的整理。iPad上有很多好用的笔记类App，例如我正在使用的Notablitiy。 手机是我们形影不离的帮手，你可以用手机中的记事本，记录下自己的想法。如果还觉得麻烦，可以通过录音，把它们保留下来。 有了创意，我们下一步就需要将它们整理起来，看看它们实现的可行性。 选择创意怎么来，我是不能帮助大家的，这只能靠大家各自的能力、经验、体验和运气了。我只能帮助大家如何从众多的创意中选择一个适合自己的。 并不是所有的创意都有让你去实现的价值。也许你有一个很好的创意，但是要花费很大的经济成本，那对你个人来说是有很大风险的，你不得不放弃。也许你有另外一个创意，但是也许别人已经在做了，只是你不知道而已，今后撞车的可能性很大。所以我们需要将它们筛选一遍，选择最适合的一个。 怎么选择呢？ 我想选择的标准很多，主要还是看你的目的是什么，你为了实现这个创意，愿意付出多大的代价： 为实现创意投入的资金是多少； 为实现创意投入的精力是多少； 实现创意的目的是为了自己的个人爱好，还是说为了靠它养家糊口； 当我们面对众多诱惑需要进行选择的时候，你可以把要选择的对象横向铺开，像我们网上购物时比较商品一样，列出它们各自具备的优点和缺点，比较它们各自的异同，找出你最偏向的那个。 举个例子这本书将把理论和实践结合在一起，所以我需要一个合适的创意做为我们后面讲解的例子。 首先明确我的目标。这个例子不能太复杂，门槛太高，会吓走很多人；但是也不能过于傻瓜，要涵盖一定的知识点，否则读完以后脑袋中还是空空如也。 计算器、视频播放器、记事本、音乐播放器、天气预报，都是一些经常可能用到的小应用。它们开发起来都不太困难，只是类型不同。 对于没有进行过安卓开发的你来说，也许根本就不知道是否困难，至少要亲自做一次之后才能知道。这里我就自己的经历来说，它们的实现还是很简单的，大家不必惊慌。 然后将这些项目在脑中进行横向对比后，给他们的各个项目点按照难易程度从1到5打分: 项目 计算器 音乐播放器 记事本 视频播放器 天气预报 体现安卓设计 1 3 5 2 4 技术简单 5 3 1 2 4 界面布局简单 5 2 1 3 4 合计得分 11 8 7 7 12 上面所列出的项目和得分都是非常主观的，项目是根据开发者的目标来制定，而得分完全根据开发者个人的偏好和经验。所以要做到评估准确，最好的办法就是多做项目，增加自己的经验值。 通过上面的评比，我决定选择天气预报来做为本书讲解的范例。","categories":[{"name":"第1章-创意","slug":"第1章-创意","permalink":"http://booktest.anddle.com/categories/第1章-创意/"}],"tags":[]}]}